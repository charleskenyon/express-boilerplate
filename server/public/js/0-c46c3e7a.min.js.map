{"version":3,"sources":["webpack:///0-c46c3e7a.min.js","webpack:///./client/scripts/testImport.js","webpack:///./node_modules/inferno/index.js","webpack:///./node_modules/inferno/dist/index.js"],"names":["webpackJsonp","4","module","exports","__webpack_require__","Object","defineProperty","value","testImportLog","undefined","_inferno","obj","__esModule","console","log","7","default","8","isStatefulComponent","o","isUndefined","prototype","render","isStringOrNumber","type","isNullOrUndef","isNull","isInvalid","isTrue","isFunction","isString","isNumber","isObject","throwError","message","ERROR_MSG","Error","combineFrom","first","second","out","key","key$1","Lifecycle","this","listeners","handleEvent","name","lastEvent","nextEvent","dom","delegatedRoots","delegatedEvents$1","get","items","Map","docEvent","attachEventToDocument","set","isiOS","trapClickOnNonInteractiveElement","delete","size","document","removeEventListener","normalizeEventName","dispatchEvent","event","target","count","isClick","eventData","eventsToTrigger","data","cancelBubble","parentDom","parentNode","nodeType","disabled","substr","toLowerCase","stopPropagation","stopImmediatePropagation","configurable","e","addEventListener","emptyFn","onclick","isCheckedType","onTextInputChange","vNode","props","EMPTY_OBJ","previousValue","onInput","oninput","newVNode","newProps","applyValue","wrappedOnChange","onChange","onCheckboxChange","onClick","processInput","nextPropsOrEmpty","mounting","isControlled","wrapped","onchange","checked","multiple","defaultValue","hasValue","setAttribute","updateChildOptionGroup","children","isArray","i","len","length","updateChildOption","isVNode","indexOf","selected","onSelectChange","applyValue$1","processSelect","wrappedOnChange$1","onTextareaInputChange","applyValue$2","processTextarea","domValue","processElement","flags","isControlledFormElement","normalizeChildNodes","firstChild","placeholder","createTextNode","replaceChild","nextSibling","lastDom","previousSibling","removeChild","hydrateComponent","lifecycle","context","isSVG","isClass","ref","_isSVG","namespaceURI","svgNS","instance","createClassComponentInstance","input","_lastInput","_vNode","hydrate","_childContext","mountClassComponentCallbacks","_updating","options","findDOMNodeEnabled","componentToDOMNodeMap","input$1","createFunctionalComponentInput","mountFunctionalComponentCallbacks","hydrateElement","className","tagName","newDom","mountElement","hydrateChildren","textContent","hasControlledValue","isFormElement","prop","patchProp","removeAttribute","mountRef","nodeValue","child","mount","nextSibling$1","hydrateText","mountText","text","hydrateVoid","hydrateRoot","recycleElement","tag","pools","elementPools","pool","nonKeyed","keyed","recycledVNode","pop","patchElement","poolElement","push","recycleComponent","componentPools","patchComponent","poolComponent","hooks","onComponentWillMount","onComponentWillUnmount","onComponentDidMount","onComponentWillUpdate","onComponentDidUpdate","unmount","canRecycle","isRecycling","unmountComponent","unmountElement","unmountVoidOrText","isStatefulComponent$$1","_unmounted","beforeUnmount","componentWillUnmount","_lifecycle","lastInput","recyclingEnabled","unmountRef","unmountChildren$1","isAttrAnEvent","patchEvent","findDOMNode","getRoot","roots","root","setRoot","removeRoot","splice","documentBody","NO_OP","directClone","trigger","lifecycle$1","patch","rootInput","createRenderer","nextInput","lastVNode","nextVNode","lastFlags","nextFlags","replaceVNode","mountComponent","patchText","patchVoid","mountVoid","replaceLastChildAndUnmount","unmountChildren","removeAllChildren","nextTag","replaceWithNewNode","lastProps","nextProps","lastChildren","nextChildren","nextRef","lastClassName","nextClassName","patchChildren","lastPropsOrEmpty","nextValue","prop$1","removeProp","patchArray","patchKeyed","setTextContent","mountArrayChildren","updateTextContent","isKeyed","patchKeyedChildren","patchNonKeyedChildren","lastType","nextType","lastKey","nextKey","childContext","hasComponentDidUpdate","componentDidUpdate","nextState","state","lastState","getChildContext","_updateComponent","didUpdate","createVoidVNode","createTextVNode","parentVNode","afterUpdate","shouldUpdate","lastProps$1","nextHooks","nextHooksDefined","lastInput$1","nextInput$1","onComponentShouldUpdate","nextText","lastChildrenLength","nextChildrenLength","commonLength","nextChild","nextChild$1","appendChild","a","b","j","aNode","bNode","nextNode","nextPos","node","aLength","bLength","aEnd","bEnd","aStart","bStart","aStartNode","bStartNode","aEndNode","bEndNode","outer","insertOrAppend","sources","Array","moved","pos","patched","keyIndex","seq","lis_algorithm","arr","u","v","c","p","slice","result","arrI","attr","lastValue","skipProps","has","booleanProps","strictProps","patchStyle","lastHtml","__html","nextHtml","innerHTML","namespaces","setAttributeNS","delegatedEvents","nameLowerCase","domEvent","linkEvent","lastAttrValue","nextAttrValue","style","domStyle","cssText","isUnitlessNumber","dom$1","documentCreateElement","childrenIsSVG","hasDidMount","componentDidMount","afterMount","addListener","Component","_blockSetState","_pendingSetState","componentWillMount","_blockRender","beforeRender","afterRender","component","newNode","insertBefore","createElementNS","createElement","lastNode","nextDom","removeChildren","VNode","createVNode","noNormalise","normalize","vNodeToClone","propsToClone","newChildren","tmpArray","props$1","propsToClone$1","cloneVNode","_children","len$2","arguments","childrenLen","hasOwnProperty","len$1","tmpArray$1","i$1","applyKey","applyKeyIfMissing","applyKeyPrefix","_normalizeVNodes","nodes","index","currentKey","n","normalizeVNodes","newNodes","normalizeChildren","normalizeProps","getFlagsForElementVnode","defaultProps","isBrowser","window","callback","listener","shift","xlinkNS","xmlNS","Set","add","navigator","platform","test","body","internal_DOMNodeMap","internal_isUnitlessNumber","internal_normalize","internal_patch","version"],"mappings":"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","file":"0-c46c3e7a.min.js","sourcesContent":["webpackJsonp([0],{\n\n/***/ 4:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.testImportLog = undefined;\n\nvar _inferno = __webpack_require__(7);\n\nvar _inferno2 = _interopRequireDefault(_inferno);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar testImportLog = function testImportLog() {\n\tconsole.log('working');\n};\n\nexports.testImportLog = testImportLog;\n\n/***/ }),\n\n/***/ 7:\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(8).default;\nmodule.exports.default = module.exports;\n\n\n\n/***/ }),\n\n/***/ 8:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * @module Inferno-Shared\r\n */ /** TypeDoc Comment */\r\n/**\r\n * @module Inferno-Shared\r\n */ /** TypeDoc Comment */ var NO_OP = '$NO_OP';\r\nvar ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';\r\n// This should be boolean and not reference to window.document\r\nvar isBrowser = !!(typeof window !== 'undefined' && window.document);\r\n// this is MUCH faster than .constructor === Array and instanceof Array\r\n// in Node 7 and the later versions of V8, slower in older versions though\r\nvar isArray = Array.isArray;\r\nfunction isStatefulComponent(o) {\r\n    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);\r\n}\r\nfunction isStringOrNumber(o) {\r\n    var type = typeof o;\r\n    return type === 'string' || type === 'number';\r\n}\r\nfunction isNullOrUndef(o) {\r\n    return isUndefined(o) || isNull(o);\r\n}\r\nfunction isInvalid(o) {\r\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\r\n}\r\nfunction isFunction(o) {\r\n    return typeof o === 'function';\r\n}\r\nfunction isString(o) {\r\n    return typeof o === 'string';\r\n}\r\nfunction isNumber(o) {\r\n    return typeof o === 'number';\r\n}\r\nfunction isNull(o) {\r\n    return o === null;\r\n}\r\nfunction isTrue(o) {\r\n    return o === true;\r\n}\r\nfunction isUndefined(o) {\r\n    return o === void 0;\r\n}\r\nfunction isObject(o) {\r\n    return typeof o === 'object';\r\n}\r\nfunction throwError(message) {\r\n    if (!message) {\r\n        message = ERROR_MSG;\r\n    }\r\n    throw new Error((\"Inferno Error: \" + message));\r\n}\r\nfunction warning(message) {\r\n    // tslint:disable-next-line:no-console\r\n    console.warn(message);\r\n}\r\nfunction combineFrom(first, second) {\r\n    var out = {};\r\n    if (first) {\r\n        for (var key in first) {\r\n            out[key] = first[key];\r\n        }\r\n    }\r\n    if (second) {\r\n        for (var key$1 in second) {\r\n            out[key$1] = second[key$1];\r\n        }\r\n    }\r\n    return out;\r\n}\r\nfunction Lifecycle() {\r\n    this.listeners = [];\r\n}\r\nLifecycle.prototype.addListener = function addListener(callback) {\r\n    this.listeners.push(callback);\r\n};\r\nLifecycle.prototype.trigger = function trigger() {\r\n    var listeners = this.listeners;\r\n    var listener;\r\n    // We need to remove current listener from array when calling it, because more listeners might be added\r\n    while (listener = listeners.shift()) {\r\n        listener();\r\n    }\r\n};\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar options = {\r\n    afterMount: null,\r\n    afterRender: null,\r\n    afterUpdate: null,\r\n    beforeRender: null,\r\n    beforeUnmount: null,\r\n    createVNode: null,\r\n    findDOMNodeEnabled: false,\r\n    recyclingEnabled: false,\r\n    roots: []\r\n};\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */ var xlinkNS = \"http://www.w3.org/1999/xlink\";\r\nvar xmlNS = \"http://www.w3.org/XML/1998/namespace\";\r\nvar svgNS = \"http://www.w3.org/2000/svg\";\r\nvar strictProps = new Set();\r\nstrictProps.add(\"volume\");\r\nstrictProps.add(\"defaultChecked\");\r\nvar booleanProps = new Set();\r\nbooleanProps.add(\"muted\");\r\nbooleanProps.add(\"scoped\");\r\nbooleanProps.add(\"loop\");\r\nbooleanProps.add(\"open\");\r\nbooleanProps.add(\"checked\");\r\nbooleanProps.add(\"default\");\r\nbooleanProps.add(\"capture\");\r\nbooleanProps.add(\"disabled\");\r\nbooleanProps.add(\"readOnly\");\r\nbooleanProps.add(\"required\");\r\nbooleanProps.add(\"autoplay\");\r\nbooleanProps.add(\"controls\");\r\nbooleanProps.add(\"seamless\");\r\nbooleanProps.add(\"reversed\");\r\nbooleanProps.add(\"allowfullscreen\");\r\nbooleanProps.add(\"novalidate\");\r\nbooleanProps.add(\"hidden\");\r\nbooleanProps.add(\"autoFocus\");\r\nbooleanProps.add(\"selected\");\r\nvar namespaces = new Map();\r\nnamespaces.set(\"xlink:href\", xlinkNS);\r\nnamespaces.set(\"xlink:arcrole\", xlinkNS);\r\nnamespaces.set(\"xlink:actuate\", xlinkNS);\r\nnamespaces.set(\"xlink:show\", xlinkNS);\r\nnamespaces.set(\"xlink:role\", xlinkNS);\r\nnamespaces.set(\"xlink:title\", xlinkNS);\r\nnamespaces.set(\"xlink:type\", xlinkNS);\r\nnamespaces.set(\"xml:base\", xmlNS);\r\nnamespaces.set(\"xml:lang\", xmlNS);\r\nnamespaces.set(\"xml:space\", xmlNS);\r\nvar isUnitlessNumber = new Set();\r\nisUnitlessNumber.add(\"animationIterationCount\");\r\nisUnitlessNumber.add(\"borderImageOutset\");\r\nisUnitlessNumber.add(\"borderImageSlice\");\r\nisUnitlessNumber.add(\"borderImageWidth\");\r\nisUnitlessNumber.add(\"boxFlex\");\r\nisUnitlessNumber.add(\"boxFlexGroup\");\r\nisUnitlessNumber.add(\"boxOrdinalGroup\");\r\nisUnitlessNumber.add(\"columnCount\");\r\nisUnitlessNumber.add(\"flex\");\r\nisUnitlessNumber.add(\"flexGrow\");\r\nisUnitlessNumber.add(\"flexPositive\");\r\nisUnitlessNumber.add(\"flexShrink\");\r\nisUnitlessNumber.add(\"flexNegative\");\r\nisUnitlessNumber.add(\"flexOrder\");\r\nisUnitlessNumber.add(\"gridRow\");\r\nisUnitlessNumber.add(\"gridColumn\");\r\nisUnitlessNumber.add(\"fontWeight\");\r\nisUnitlessNumber.add(\"lineClamp\");\r\nisUnitlessNumber.add(\"lineHeight\");\r\nisUnitlessNumber.add(\"opacity\");\r\nisUnitlessNumber.add(\"order\");\r\nisUnitlessNumber.add(\"orphans\");\r\nisUnitlessNumber.add(\"tabSize\");\r\nisUnitlessNumber.add(\"widows\");\r\nisUnitlessNumber.add(\"zIndex\");\r\nisUnitlessNumber.add(\"zoom\");\r\nisUnitlessNumber.add(\"fillOpacity\");\r\nisUnitlessNumber.add(\"floodOpacity\");\r\nisUnitlessNumber.add(\"stopOpacity\");\r\nisUnitlessNumber.add(\"strokeDasharray\");\r\nisUnitlessNumber.add(\"strokeDashoffset\");\r\nisUnitlessNumber.add(\"strokeMiterlimit\");\r\nisUnitlessNumber.add(\"strokeOpacity\");\r\nisUnitlessNumber.add(\"strokeWidth\");\r\nvar skipProps = new Set();\r\nskipProps.add(\"children\");\r\nskipProps.add(\"childrenType\");\r\nskipProps.add(\"defaultValue\");\r\nskipProps.add(\"ref\");\r\nskipProps.add(\"key\");\r\nskipProps.add(\"checked\");\r\nskipProps.add(\"multiple\");\r\nvar delegatedEvents = new Set();\r\ndelegatedEvents.add(\"onClick\");\r\ndelegatedEvents.add(\"onMouseDown\");\r\ndelegatedEvents.add(\"onMouseUp\");\r\ndelegatedEvents.add(\"onMouseMove\");\r\ndelegatedEvents.add(\"onSubmit\");\r\ndelegatedEvents.add(\"onDblClick\");\r\ndelegatedEvents.add(\"onKeyDown\");\r\ndelegatedEvents.add(\"onKeyUp\");\r\ndelegatedEvents.add(\"onKeyPress\");\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar isiOS = isBrowser && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);\r\nvar delegatedEvents$1 = new Map();\r\nfunction handleEvent(name, lastEvent, nextEvent, dom) {\r\n    var delegatedRoots = delegatedEvents$1.get(name);\r\n    if (nextEvent) {\r\n        if (!delegatedRoots) {\r\n            delegatedRoots = { items: new Map(), docEvent: null };\r\n            delegatedRoots.docEvent = attachEventToDocument(name, delegatedRoots);\r\n            delegatedEvents$1.set(name, delegatedRoots);\r\n        }\r\n        if (!lastEvent) {\r\n            if (isiOS && name === 'onClick') {\r\n                trapClickOnNonInteractiveElement(dom);\r\n            }\r\n        }\r\n        delegatedRoots.items.set(dom, nextEvent);\r\n    }\r\n    else if (delegatedRoots) {\r\n        var items = delegatedRoots.items;\r\n        if (items.delete(dom)) {\r\n            // If any items were deleted, check if listener need to be removed\r\n            if (items.size === 0) {\r\n                document.removeEventListener(normalizeEventName(name), delegatedRoots.docEvent);\r\n                delegatedEvents$1.delete(name);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction dispatchEvent(event, target, items, count, isClick, eventData) {\r\n    var eventsToTrigger = items.get(target);\r\n    if (eventsToTrigger) {\r\n        count--;\r\n        // linkEvent object\r\n        eventData.dom = target;\r\n        if (eventsToTrigger.event) {\r\n            eventsToTrigger.event(eventsToTrigger.data, event);\r\n        }\r\n        else {\r\n            eventsToTrigger(event);\r\n        }\r\n        if (event.cancelBubble) {\r\n            return;\r\n        }\r\n    }\r\n    if (count > 0) {\r\n        var parentDom = target.parentNode;\r\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\r\n        // because the event listener is on document.body\r\n        // Don't process clicks on disabled elements\r\n        if (parentDom === null || (isClick && parentDom.nodeType === 1 && parentDom.disabled)) {\r\n            return;\r\n        }\r\n        dispatchEvent(event, parentDom, items, count, isClick, eventData);\r\n    }\r\n}\r\nfunction normalizeEventName(name) {\r\n    return name.substr(2).toLowerCase();\r\n}\r\nfunction stopPropagation() {\r\n    this.cancelBubble = true;\r\n    this.stopImmediatePropagation();\r\n}\r\nfunction attachEventToDocument(name, delegatedRoots) {\r\n    var docEvent = function (event) {\r\n        var count = delegatedRoots.items.size;\r\n        if (count > 0) {\r\n            event.stopPropagation = stopPropagation;\r\n            // Event data needs to be object to save reference to currentTarget getter\r\n            var eventData = {\r\n                dom: document\r\n            };\r\n            try {\r\n                Object.defineProperty(event, 'currentTarget', {\r\n                    configurable: true,\r\n                    get: function get() {\r\n                        return eventData.dom;\r\n                    }\r\n                });\r\n            }\r\n            catch (e) { }\r\n            dispatchEvent(event, event.target, delegatedRoots.items, count, event.type === 'click', eventData);\r\n        }\r\n    };\r\n    document.addEventListener(normalizeEventName(name), docEvent);\r\n    return docEvent;\r\n}\r\n// tslint:disable-next-line:no-empty\r\nfunction emptyFn() { }\r\nfunction trapClickOnNonInteractiveElement(dom) {\r\n    // Mobile Safari does not fire properly bubble click events on\r\n    // non-interactive elements, which means delegated click listeners do not\r\n    // fire. The workaround for this bug involves attaching an empty click\r\n    // listener on the target node.\r\n    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\r\n    // Just set it using the onclick property so that we don't have to manage any\r\n    // bookkeeping for it. Not sure if we need to clear it when the listener is\r\n    // removed.\r\n    // TODO: Only do this for the relevant Safaris maybe?\r\n    dom.onclick = emptyFn;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction isCheckedType(type) {\r\n    return type === 'checkbox' || type === 'radio';\r\n}\r\nfunction onTextInputChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    var previousValue = props.value;\r\n    if (props.onInput) {\r\n        var event = props.onInput;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.oninput) {\r\n        props.oninput(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue(newProps, dom);\r\n    }\r\n}\r\nfunction wrappedOnChange(e) {\r\n    var props = this.vNode.props || EMPTY_OBJ;\r\n    var event = props.onChange;\r\n    if (event.event) {\r\n        event.event(event.data, e);\r\n    }\r\n    else {\r\n        event(e);\r\n    }\r\n}\r\nfunction onCheckboxChange(e) {\r\n    e.stopPropagation(); // This click should not propagate its for internal use\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    if (props.onClick) {\r\n        var event = props.onClick;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.onclick) {\r\n        props.onclick(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    applyValue(newProps, dom);\r\n}\r\nfunction processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue(nextPropsOrEmpty, dom);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            if (isCheckedType(nextPropsOrEmpty.type)) {\r\n                dom.onclick = onCheckboxChange;\r\n                dom.onclick.wrapped = true;\r\n            }\r\n            else {\r\n                dom.oninput = onTextInputChange;\r\n                dom.oninput.wrapped = true;\r\n            }\r\n            if (nextPropsOrEmpty.onChange) {\r\n                dom.onchange = wrappedOnChange;\r\n                dom.onchange.wrapped = true;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction applyValue(nextPropsOrEmpty, dom) {\r\n    var type = nextPropsOrEmpty.type;\r\n    var value = nextPropsOrEmpty.value;\r\n    var checked = nextPropsOrEmpty.checked;\r\n    var multiple = nextPropsOrEmpty.multiple;\r\n    var defaultValue = nextPropsOrEmpty.defaultValue;\r\n    var hasValue = !isNullOrUndef(value);\r\n    if (type && type !== dom.type) {\r\n        dom.setAttribute('type', type);\r\n    }\r\n    if (multiple && multiple !== dom.multiple) {\r\n        dom.multiple = multiple;\r\n    }\r\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\r\n        dom.defaultValue = defaultValue + '';\r\n    }\r\n    if (isCheckedType(type)) {\r\n        if (hasValue) {\r\n            dom.value = value;\r\n        }\r\n        if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n    else {\r\n        if (hasValue && dom.value !== value) {\r\n            dom.defaultValue = value;\r\n            dom.value = value;\r\n        }\r\n        else if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction updateChildOptionGroup(vNode, value) {\r\n    var type = vNode.type;\r\n    if (type === 'optgroup') {\r\n        var children = vNode.children;\r\n        if (isArray(children)) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOption(children[i], value);\r\n            }\r\n        }\r\n        else if (isVNode(children)) {\r\n            updateChildOption(children, value);\r\n        }\r\n    }\r\n    else {\r\n        updateChildOption(vNode, value);\r\n    }\r\n}\r\nfunction updateChildOption(vNode, value) {\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    // we do this as multiple may have changed\r\n    dom.value = props.value;\r\n    if ((isArray(value) && value.indexOf(props.value) !== -1) || props.value === value) {\r\n        dom.selected = true;\r\n    }\r\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\r\n        dom.selected = props.selected || false;\r\n    }\r\n}\r\nfunction onSelectChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    var previousValue = props.value;\r\n    if (props.onChange) {\r\n        var event = props.onChange;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.onchange) {\r\n        props.onchange(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue$1(newVNode, dom, newProps, false);\r\n    }\r\n}\r\nfunction processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue$1(vNode, dom, nextPropsOrEmpty, mounting);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            dom.onchange = onSelectChange;\r\n            dom.onchange.wrapped = true;\r\n        }\r\n    }\r\n}\r\nfunction applyValue$1(vNode, dom, nextPropsOrEmpty, mounting) {\r\n    if (nextPropsOrEmpty.multiple !== dom.multiple) {\r\n        dom.multiple = nextPropsOrEmpty.multiple;\r\n    }\r\n    var children = vNode.children;\r\n    if (!isInvalid(children)) {\r\n        var value = nextPropsOrEmpty.value;\r\n        if (mounting && isNullOrUndef(value)) {\r\n            value = nextPropsOrEmpty.defaultValue;\r\n        }\r\n        if (isArray(children)) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOptionGroup(children[i], value);\r\n            }\r\n        }\r\n        else if (isVNode(children)) {\r\n            updateChildOptionGroup(children, value);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction wrappedOnChange$1(e) {\r\n    var props = this.vNode.props || EMPTY_OBJ;\r\n    var event = props.onChange;\r\n    if (event.event) {\r\n        event.event(event.data, e);\r\n    }\r\n    else {\r\n        event(e);\r\n    }\r\n}\r\nfunction onTextareaInputChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var previousValue = props.value;\r\n    if (props.onInput) {\r\n        var event = props.onInput;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.oninput) {\r\n        props.oninput(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue$2(newVNode, vNode.dom, false);\r\n    }\r\n}\r\nfunction processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue$2(nextPropsOrEmpty, dom, mounting);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            dom.oninput = onTextareaInputChange;\r\n            dom.oninput.wrapped = true;\r\n            if (nextPropsOrEmpty.onChange) {\r\n                dom.onchange = wrappedOnChange$1;\r\n                dom.onchange.wrapped = true;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction applyValue$2(nextPropsOrEmpty, dom, mounting) {\r\n    var value = nextPropsOrEmpty.value;\r\n    var domValue = dom.value;\r\n    if (isNullOrUndef(value)) {\r\n        if (mounting) {\r\n            var defaultValue = nextPropsOrEmpty.defaultValue;\r\n            if (!isNullOrUndef(defaultValue)) {\r\n                if (defaultValue !== domValue) {\r\n                    dom.defaultValue = defaultValue;\r\n                    dom.value = defaultValue;\r\n                }\r\n            }\r\n            else if (domValue !== '') {\r\n                dom.defaultValue = '';\r\n                dom.value = '';\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        /* There is value so keep it controlled */\r\n        if (domValue !== value) {\r\n            dom.defaultValue = value;\r\n            dom.value = value;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * There is currently no support for switching same input between controlled and nonControlled\r\n * If that ever becomes a real issue, then re design controlled elements\r\n * Currently user must choose either controlled or non-controlled and stick with that\r\n */\r\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    if (flags & 512 /* InputElement */) {\r\n        processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n    if (flags & 2048 /* SelectElement */) {\r\n        processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n    if (flags & 1024 /* TextareaElement */) {\r\n        processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n}\r\nfunction isControlledFormElement(nextPropsOrEmpty) {\r\n    return (nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type)) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction normalizeChildNodes(parentDom) {\r\n    var dom = parentDom.firstChild;\r\n    while (dom) {\r\n        if (dom.nodeType === 8) {\r\n            if (dom.data === \"!\") {\r\n                var placeholder = document.createTextNode(\"\");\r\n                parentDom.replaceChild(placeholder, dom);\r\n                dom = dom.nextSibling;\r\n            }\r\n            else {\r\n                var lastDom = dom.previousSibling;\r\n                parentDom.removeChild(dom);\r\n                dom = lastDom || parentDom.firstChild;\r\n            }\r\n        }\r\n        else {\r\n            dom = dom.nextSibling;\r\n        }\r\n    }\r\n}\r\nfunction hydrateComponent(vNode, dom, lifecycle, context, isSVG, isClass) {\r\n    var type = vNode.type;\r\n    var ref = vNode.ref;\r\n    vNode.dom = dom;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    if (isClass) {\r\n        var _isSVG = dom.namespaceURI === svgNS;\r\n        var instance = createClassComponentInstance(vNode, type, props, context, _isSVG, lifecycle);\r\n        var input = instance._lastInput;\r\n        instance._vNode = vNode;\r\n        hydrate(input, dom, lifecycle, instance._childContext, _isSVG);\r\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\r\n        instance._updating = false; // Mount finished allow going sync\r\n        if (options.findDOMNodeEnabled) {\r\n            componentToDOMNodeMap.set(instance, dom);\r\n        }\r\n    }\r\n    else {\r\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\r\n        hydrate(input$1, dom, lifecycle, context, isSVG);\r\n        vNode.children = input$1;\r\n        vNode.dom = input$1.dom;\r\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\r\n    }\r\n    return dom;\r\n}\r\nfunction hydrateElement(vNode, dom, lifecycle, context, isSVG) {\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var flags = vNode.flags;\r\n    var ref = vNode.ref;\r\n    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;\r\n    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {\r\n        if (false) {\r\n            warning(\"Inferno hydration: Server-side markup doesn't match client-side markup or Initial render target is not empty\");\r\n        }\r\n        var newDom = mountElement(vNode, null, lifecycle, context, isSVG);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n        return newDom;\r\n    }\r\n    vNode.dom = dom;\r\n    if (children) {\r\n        hydrateChildren(children, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (dom.firstChild !== null) {\r\n        dom.textContent = \"\"; // dom has content, but VNode has no children remove everything from DOM\r\n    }\r\n    if (props) {\r\n        var hasControlledValue = false;\r\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\r\n        if (isFormElement) {\r\n            hasControlledValue = isControlledFormElement(props);\r\n        }\r\n        for (var prop in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\r\n        }\r\n        if (isFormElement) {\r\n            processElement(flags, vNode, dom, props, true, hasControlledValue);\r\n        }\r\n    }\r\n    if (!isNullOrUndef(className)) {\r\n        if (isSVG) {\r\n            dom.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n    }\r\n    else {\r\n        if (dom.className !== \"\") {\r\n            dom.removeAttribute(\"class\");\r\n        }\r\n    }\r\n    if (ref) {\r\n        mountRef(dom, ref, lifecycle);\r\n    }\r\n    return dom;\r\n}\r\nfunction hydrateChildren(children, parentDom, lifecycle, context, isSVG) {\r\n    normalizeChildNodes(parentDom);\r\n    var dom = parentDom.firstChild;\r\n    if (isStringOrNumber(children)) {\r\n        if (!isNull(dom) && dom.nodeType === 3) {\r\n            if (dom.nodeValue !== children) {\r\n                dom.nodeValue = children;\r\n            }\r\n        }\r\n        else if (children) {\r\n            parentDom.textContent = children;\r\n        }\r\n        if (!isNull(dom)) {\r\n            dom = dom.nextSibling;\r\n        }\r\n    }\r\n    else if (isArray(children)) {\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            if (!isNull(child) && isObject(child)) {\r\n                if (!isNull(dom)) {\r\n                    var nextSibling = dom.nextSibling;\r\n                    hydrate(child, dom, lifecycle, context, isSVG);\r\n                    dom = nextSibling;\r\n                }\r\n                else {\r\n                    mount(child, parentDom, lifecycle, context, isSVG);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // It's VNode\r\n        if (!isNull(dom)) {\r\n            hydrate(children, dom, lifecycle, context, isSVG);\r\n            dom = dom.nextSibling;\r\n        }\r\n        else {\r\n            mount(children, parentDom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    // clear any other DOM nodes, there should be only a single entry for the root\r\n    while (dom) {\r\n        var nextSibling$1 = dom.nextSibling;\r\n        parentDom.removeChild(dom);\r\n        dom = nextSibling$1;\r\n    }\r\n}\r\nfunction hydrateText(vNode, dom) {\r\n    if (dom.nodeType !== 3) {\r\n        var newDom = mountText(vNode, null);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n        return newDom;\r\n    }\r\n    var text = vNode.children;\r\n    if (dom.nodeValue !== text) {\r\n        dom.nodeValue = text;\r\n    }\r\n    vNode.dom = dom;\r\n    return dom;\r\n}\r\nfunction hydrateVoid(vNode, dom) {\r\n    vNode.dom = dom;\r\n    return dom;\r\n}\r\nfunction hydrate(vNode, dom, lifecycle, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 28 /* Component */) {\r\n        hydrateComponent(vNode, dom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        hydrateElement(vNode, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        hydrateText(vNode, dom);\r\n    }\r\n    else if (flags & 4096 /* Void */) {\r\n        hydrateVoid(vNode, dom);\r\n    }\r\n    else {\r\n        if (false) {\r\n            throwError((\"hydrate() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\r\n        }\r\n        throwError();\r\n    }\r\n}\r\nfunction hydrateRoot(input, parentDom, lifecycle) {\r\n    if (!isNull(parentDom)) {\r\n        var dom = parentDom.firstChild;\r\n        if (!isNull(dom)) {\r\n            hydrate(input, dom, lifecycle, EMPTY_OBJ, false);\r\n            dom = parentDom.firstChild;\r\n            // clear any other DOM nodes, there should be only a single entry for the root\r\n            while ((dom = dom.nextSibling)) {\r\n                parentDom.removeChild(dom);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar componentPools = new Map();\r\nvar elementPools = new Map();\r\nfunction recycleElement(vNode, lifecycle, context, isSVG) {\r\n    var tag = vNode.type;\r\n    var pools = elementPools.get(tag);\r\n    if (!isUndefined(pools)) {\r\n        var key = vNode.key;\r\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\r\n        if (!isUndefined(pool)) {\r\n            var recycledVNode = pool.pop();\r\n            if (!isUndefined(recycledVNode)) {\r\n                patchElement(recycledVNode, vNode, null, lifecycle, context, isSVG, true);\r\n                return vNode.dom;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction poolElement(vNode) {\r\n    var tag = vNode.type;\r\n    var key = vNode.key;\r\n    var pools = elementPools.get(tag);\r\n    if (isUndefined(pools)) {\r\n        pools = {\r\n            keyed: new Map(),\r\n            nonKeyed: []\r\n        };\r\n        elementPools.set(tag, pools);\r\n    }\r\n    if (isNull(key)) {\r\n        pools.nonKeyed.push(vNode);\r\n    }\r\n    else {\r\n        var pool = pools.keyed.get(key);\r\n        if (isUndefined(pool)) {\r\n            pool = [];\r\n            pools.keyed.set(key, pool);\r\n        }\r\n        pool.push(vNode);\r\n    }\r\n}\r\nfunction recycleComponent(vNode, lifecycle, context, isSVG) {\r\n    var type = vNode.type;\r\n    var pools = componentPools.get(type);\r\n    if (!isUndefined(pools)) {\r\n        var key = vNode.key;\r\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\r\n        if (!isUndefined(pool)) {\r\n            var recycledVNode = pool.pop();\r\n            if (!isUndefined(recycledVNode)) {\r\n                var flags = vNode.flags;\r\n                var failed = patchComponent(recycledVNode, vNode, null, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0, true);\r\n                if (!failed) {\r\n                    return vNode.dom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction poolComponent(vNode) {\r\n    var hooks = vNode.ref;\r\n    var nonRecycleHooks = hooks &&\r\n        (hooks.onComponentWillMount ||\r\n            hooks.onComponentWillUnmount ||\r\n            hooks.onComponentDidMount ||\r\n            hooks.onComponentWillUpdate ||\r\n            hooks.onComponentDidUpdate);\r\n    if (nonRecycleHooks) {\r\n        return;\r\n    }\r\n    var type = vNode.type;\r\n    var key = vNode.key;\r\n    var pools = componentPools.get(type);\r\n    if (isUndefined(pools)) {\r\n        pools = {\r\n            keyed: new Map(),\r\n            nonKeyed: []\r\n        };\r\n        componentPools.set(type, pools);\r\n    }\r\n    if (isNull(key)) {\r\n        pools.nonKeyed.push(vNode);\r\n    }\r\n    else {\r\n        var pool = pools.keyed.get(key);\r\n        if (isUndefined(pool)) {\r\n            pool = [];\r\n            pools.keyed.set(key, pool);\r\n        }\r\n        pool.push(vNode);\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction unmount(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var flags = vNode.flags;\r\n    if (flags & 28 /* Component */) {\r\n        unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling);\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling);\r\n    }\r\n    else if (flags & (1 /* Text */ | 4096 /* Void */)) {\r\n        unmountVoidOrText(vNode, parentDom);\r\n    }\r\n}\r\nfunction unmountVoidOrText(vNode, parentDom) {\r\n    if (!isNull(parentDom)) {\r\n        removeChild(parentDom, vNode.dom);\r\n    }\r\n}\r\nfunction unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var instance = vNode.children;\r\n    var flags = vNode.flags;\r\n    var isStatefulComponent$$1 = flags & 4;\r\n    var ref = vNode.ref;\r\n    var dom = vNode.dom;\r\n    if (!isRecycling) {\r\n        if (isStatefulComponent$$1) {\r\n            if (!instance._unmounted) {\r\n                if (!isNull(options.beforeUnmount)) {\r\n                    options.beforeUnmount(vNode);\r\n                }\r\n                if (!isUndefined(instance.componentWillUnmount)) {\r\n                    instance.componentWillUnmount();\r\n                }\r\n                if (ref && !isRecycling) {\r\n                    ref(null);\r\n                }\r\n                instance._unmounted = true;\r\n                if (options.findDOMNodeEnabled) {\r\n                    componentToDOMNodeMap.delete(instance);\r\n                }\r\n                unmount(instance._lastInput, null, instance._lifecycle, false, isRecycling);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndef(ref)) {\r\n                if (!isNullOrUndef(ref.onComponentWillUnmount)) {\r\n                    ref.onComponentWillUnmount(dom);\r\n                }\r\n            }\r\n            unmount(instance, null, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n    if (parentDom) {\r\n        var lastInput = instance._lastInput;\r\n        if (isNullOrUndef(lastInput)) {\r\n            lastInput = instance;\r\n        }\r\n        removeChild(parentDom, dom);\r\n    }\r\n    if (options.recyclingEnabled &&\r\n        !isStatefulComponent$$1 &&\r\n        (parentDom || canRecycle)) {\r\n        poolComponent(vNode);\r\n    }\r\n}\r\nfunction unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var dom = vNode.dom;\r\n    var ref = vNode.ref;\r\n    var props = vNode.props;\r\n    if (ref && !isRecycling) {\r\n        unmountRef(ref);\r\n    }\r\n    var children = vNode.children;\r\n    if (!isNullOrUndef(children)) {\r\n        unmountChildren$1(children, lifecycle, isRecycling);\r\n    }\r\n    if (!isNull(props)) {\r\n        for (var name in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            if (props[name] !== null && isAttrAnEvent(name)) {\r\n                patchEvent(name, props[name], null, dom);\r\n                // We need to set this null, because same props otherwise come back if SCU returns false and we are recyling\r\n                props[name] = null;\r\n            }\r\n        }\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        removeChild(parentDom, dom);\r\n    }\r\n    if (options.recyclingEnabled && (parentDom || canRecycle)) {\r\n        poolElement(vNode);\r\n    }\r\n}\r\nfunction unmountChildren$1(children, lifecycle, isRecycling) {\r\n    if (isArray(children)) {\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            if (!isInvalid(child) && isObject(child)) {\r\n                unmount(child, null, lifecycle, false, isRecycling);\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(children)) {\r\n        unmount(children, null, lifecycle, false, isRecycling);\r\n    }\r\n}\r\nfunction unmountRef(ref) {\r\n    if (isFunction(ref)) {\r\n        ref(null);\r\n    }\r\n    else {\r\n        if (isInvalid(ref)) {\r\n            return;\r\n        }\r\n        if (false) {\r\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n        }\r\n        throwError();\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n// rather than use a Map, like we did before, we can use an array here\r\n// given there shouldn't be THAT many roots on the page, the difference\r\n// in performance is huge: https://esbench.com/bench/5802a691330ab09900a1a2da\r\nvar componentToDOMNodeMap = new Map();\r\nvar roots = options.roots;\r\n/**\r\n * When inferno.options.findDOMNOdeEnabled is true, this function will return DOM Node by component instance\r\n * @param ref Component instance\r\n * @returns {*|null} returns dom node\r\n */\r\nfunction findDOMNode(ref) {\r\n    if (!options.findDOMNodeEnabled) {\r\n        if (false) {\r\n            throwError(\"findDOMNode() has been disabled, use Inferno.options.findDOMNodeEnabled = true; enabled findDOMNode(). Warning this can significantly impact performance!\");\r\n        }\r\n        throwError();\r\n    }\r\n    var dom = ref && ref.nodeType ? ref : null;\r\n    return componentToDOMNodeMap.get(ref) || dom;\r\n}\r\nfunction getRoot(dom) {\r\n    for (var i = 0, len = roots.length; i < len; i++) {\r\n        var root = roots[i];\r\n        if (root.dom === dom) {\r\n            return root;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction setRoot(dom, input, lifecycle) {\r\n    var root = {\r\n        dom: dom,\r\n        input: input,\r\n        lifecycle: lifecycle\r\n    };\r\n    roots.push(root);\r\n    return root;\r\n}\r\nfunction removeRoot(root) {\r\n    for (var i = 0, len = roots.length; i < len; i++) {\r\n        if (roots[i] === root) {\r\n            roots.splice(i, 1);\r\n            return;\r\n        }\r\n    }\r\n}\r\nif (false) {\r\n    if (isBrowser && document.body === null) {\r\n        warning('Inferno warning: you cannot initialize inferno without \"document.body\". Wait on \"DOMContentLoaded\" event, add script to bottom of body, or use async/defer attributes on script tag.');\r\n    }\r\n}\r\nvar documentBody = isBrowser ? document.body : null;\r\n/**\r\n * Renders virtual node tree into parent node.\r\n * @param {VNode | null | string | number} input vNode to be rendered\r\n * @param parentDom DOM node which content will be replaced by virtual node\r\n * @returns {InfernoChildren} rendered virtual node\r\n */\r\nfunction render(input, parentDom) {\r\n    if (documentBody === parentDom) {\r\n        if (false) {\r\n            throwError('you cannot render() to the \"document.body\". Use an empty element as a container instead.');\r\n        }\r\n        throwError();\r\n    }\r\n    if (input === NO_OP) {\r\n        return;\r\n    }\r\n    var root = getRoot(parentDom);\r\n    if (isNull(root)) {\r\n        var lifecycle = new Lifecycle();\r\n        if (!isInvalid(input)) {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            if (!hydrateRoot(input, parentDom, lifecycle)) {\r\n                mount(input, parentDom, lifecycle, EMPTY_OBJ, false);\r\n            }\r\n            root = setRoot(parentDom, input, lifecycle);\r\n            lifecycle.trigger();\r\n        }\r\n    }\r\n    else {\r\n        var lifecycle$1 = root.lifecycle;\r\n        lifecycle$1.listeners = [];\r\n        if (isNullOrUndef(input)) {\r\n            unmount(root.input, parentDom, lifecycle$1, false, false);\r\n            removeRoot(root);\r\n        }\r\n        else {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            patch(root.input, input, parentDom, lifecycle$1, EMPTY_OBJ, false, false);\r\n        }\r\n        root.input = input;\r\n        lifecycle$1.trigger();\r\n    }\r\n    if (root) {\r\n        var rootInput = root.input;\r\n        if (rootInput && rootInput.flags & 28 /* Component */) {\r\n            return rootInput.children;\r\n        }\r\n    }\r\n}\r\nfunction createRenderer(parentDom) {\r\n    return function renderer(lastInput, nextInput) {\r\n        if (!parentDom) {\r\n            parentDom = lastInput;\r\n        }\r\n        render(nextInput, parentDom);\r\n    };\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction patch(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    if (lastVNode !== nextVNode) {\r\n        var lastFlags = lastVNode.flags;\r\n        var nextFlags = nextVNode.flags;\r\n        if (nextFlags & 28 /* Component */) {\r\n            var isClass = (nextFlags & 4 /* ComponentClass */) > 0;\r\n            if (lastFlags & 28 /* Component */) {\r\n                patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, isClass), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 3970 /* Element */) {\r\n            if (lastFlags & 3970 /* Element */) {\r\n                patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountElement(nextVNode, null, lifecycle, context, isSVG), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 1 /* Text */) {\r\n            if (lastFlags & 1 /* Text */) {\r\n                patchText(lastVNode, nextVNode);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountText(nextVNode, null), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 4096 /* Void */) {\r\n            if (lastFlags & 4096 /* Void */) {\r\n                patchVoid(lastVNode, nextVNode);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountVoid(nextVNode, null), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else {\r\n            // Error case: mount new one replacing old one\r\n            replaceLastChildAndUnmount(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction unmountChildren(children, dom, lifecycle, isRecycling) {\r\n    if (isVNode(children)) {\r\n        unmount(children, dom, lifecycle, true, isRecycling);\r\n    }\r\n    else if (isArray(children)) {\r\n        removeAllChildren(dom, children, lifecycle, isRecycling);\r\n    }\r\n    else {\r\n        dom.textContent = \"\";\r\n    }\r\n}\r\nfunction patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    var nextTag = nextVNode.type;\r\n    var lastTag = lastVNode.type;\r\n    if (lastTag !== nextTag) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n    }\r\n    else {\r\n        var dom = lastVNode.dom;\r\n        var lastProps = lastVNode.props;\r\n        var nextProps = nextVNode.props;\r\n        var lastChildren = lastVNode.children;\r\n        var nextChildren = nextVNode.children;\r\n        var lastFlags = lastVNode.flags;\r\n        var nextFlags = nextVNode.flags;\r\n        var nextRef = nextVNode.ref;\r\n        var lastClassName = lastVNode.className;\r\n        var nextClassName = nextVNode.className;\r\n        nextVNode.dom = dom;\r\n        isSVG = isSVG || (nextFlags & 128 /* SvgElement */) > 0;\r\n        if (lastChildren !== nextChildren) {\r\n            var childrenIsSVG = isSVG === true && nextVNode.type !== \"foreignObject\";\r\n            patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, childrenIsSVG, isRecycling);\r\n        }\r\n        // inlined patchProps  -- starts --\r\n        if (lastProps !== nextProps) {\r\n            var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\r\n            var nextPropsOrEmpty = nextProps || EMPTY_OBJ;\r\n            var hasControlledValue = false;\r\n            if (nextPropsOrEmpty !== EMPTY_OBJ) {\r\n                var isFormElement = (nextFlags & 3584 /* FormElement */) > 0;\r\n                if (isFormElement) {\r\n                    hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\r\n                }\r\n                for (var prop in nextPropsOrEmpty) {\r\n                    // do not add a hasOwnProperty check here, it affects performance\r\n                    var nextValue = nextPropsOrEmpty[prop];\r\n                    var lastValue = lastPropsOrEmpty[prop];\r\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue);\r\n                }\r\n                if (isFormElement) {\r\n                    // When inferno is recycling form element, we need to process it like it would be mounting\r\n                    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, isRecycling, hasControlledValue);\r\n                }\r\n            }\r\n            if (lastPropsOrEmpty !== EMPTY_OBJ) {\r\n                for (var prop$1 in lastPropsOrEmpty) {\r\n                    // do not add a hasOwnProperty check here, it affects performance\r\n                    if (isNullOrUndef(nextPropsOrEmpty[prop$1]) &&\r\n                        !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\r\n                        removeProp(prop$1, lastPropsOrEmpty[prop$1], dom, nextFlags);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // inlined patchProps  -- ends --\r\n        if (lastClassName !== nextClassName) {\r\n            if (isNullOrUndef(nextClassName)) {\r\n                dom.removeAttribute(\"class\");\r\n            }\r\n            else {\r\n                if (isSVG) {\r\n                    dom.setAttribute(\"class\", nextClassName);\r\n                }\r\n                else {\r\n                    dom.className = nextClassName;\r\n                }\r\n            }\r\n        }\r\n        if (nextRef) {\r\n            if (lastVNode.ref !== nextRef || isRecycling) {\r\n                mountRef(dom, nextRef, lifecycle);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var patchArray = false;\r\n    var patchKeyed = false;\r\n    if (nextFlags & 64 /* HasNonKeyedChildren */) {\r\n        patchArray = true;\r\n    }\r\n    else if ((lastFlags & 32 /* HasKeyedChildren */) > 0 &&\r\n        (nextFlags & 32 /* HasKeyedChildren */) > 0) {\r\n        patchKeyed = true;\r\n        patchArray = true;\r\n    }\r\n    else if (isInvalid(nextChildren)) {\r\n        unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n    }\r\n    else if (isInvalid(lastChildren)) {\r\n        if (isStringOrNumber(nextChildren)) {\r\n            setTextContent(dom, nextChildren);\r\n        }\r\n        else {\r\n            if (isArray(nextChildren)) {\r\n                mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\r\n            }\r\n            else {\r\n                mount(nextChildren, dom, lifecycle, context, isSVG);\r\n            }\r\n        }\r\n    }\r\n    else if (isStringOrNumber(nextChildren)) {\r\n        if (isStringOrNumber(lastChildren)) {\r\n            updateTextContent(dom, nextChildren);\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            setTextContent(dom, nextChildren);\r\n        }\r\n    }\r\n    else if (isArray(nextChildren)) {\r\n        if (isArray(lastChildren)) {\r\n            patchArray = true;\r\n            if (isKeyed(lastChildren, nextChildren)) {\r\n                patchKeyed = true;\r\n            }\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    else if (isArray(lastChildren)) {\r\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\r\n        mount(nextChildren, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (isVNode(nextChildren)) {\r\n        if (isVNode(lastChildren)) {\r\n            patch(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            mount(nextChildren, dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    if (patchArray) {\r\n        if (patchKeyed) {\r\n            patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n        else {\r\n            patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling) {\r\n    var lastType = lastVNode.type;\r\n    var nextType = nextVNode.type;\r\n    var lastKey = lastVNode.key;\r\n    var nextKey = nextVNode.key;\r\n    if (lastType !== nextType || lastKey !== nextKey) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n        return false;\r\n    }\r\n    else {\r\n        var nextProps = nextVNode.props || EMPTY_OBJ;\r\n        if (isClass) {\r\n            var instance = lastVNode.children;\r\n            instance._updating = true;\r\n            if (instance._unmounted) {\r\n                if (isNull(parentDom)) {\r\n                    return true;\r\n                }\r\n                replaceChild(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, (nextVNode.flags & 4 /* ComponentClass */) > 0), lastVNode.dom);\r\n            }\r\n            else {\r\n                var hasComponentDidUpdate = !isUndefined(instance.componentDidUpdate);\r\n                var nextState = instance.state;\r\n                // When component has componentDidUpdate hook, we need to clone lastState or will be modified by reference during update\r\n                var lastState = hasComponentDidUpdate\r\n                    ? combineFrom(nextState, null)\r\n                    : nextState;\r\n                var lastProps = instance.props;\r\n                var childContext;\r\n                if (!isNullOrUndef(instance.getChildContext)) {\r\n                    childContext = instance.getChildContext();\r\n                }\r\n                nextVNode.children = instance;\r\n                instance._isSVG = isSVG;\r\n                if (isNullOrUndef(childContext)) {\r\n                    childContext = context;\r\n                }\r\n                else {\r\n                    childContext = combineFrom(context, childContext);\r\n                }\r\n                var lastInput = instance._lastInput;\r\n                var nextInput = instance._updateComponent(lastState, nextState, lastProps, nextProps, context, false, false);\r\n                var didUpdate = true;\r\n                instance._childContext = childContext;\r\n                if (isInvalid(nextInput)) {\r\n                    nextInput = createVoidVNode();\r\n                }\r\n                else if (nextInput === NO_OP) {\r\n                    nextInput = lastInput;\r\n                    didUpdate = false;\r\n                }\r\n                else if (isStringOrNumber(nextInput)) {\r\n                    nextInput = createTextVNode(nextInput, null);\r\n                }\r\n                else if (isArray(nextInput)) {\r\n                    if (false) {\r\n                        throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n                    }\r\n                    throwError();\r\n                }\r\n                else if (isObject(nextInput)) {\r\n                    if (!isNull(nextInput.dom)) {\r\n                        nextInput = directClone(nextInput);\r\n                    }\r\n                }\r\n                if (nextInput.flags & 28 /* Component */) {\r\n                    nextInput.parentVNode = nextVNode;\r\n                }\r\n                else if (lastInput.flags & 28 /* Component */) {\r\n                    lastInput.parentVNode = nextVNode;\r\n                }\r\n                instance._lastInput = nextInput;\r\n                instance._vNode = nextVNode;\r\n                if (didUpdate) {\r\n                    patch(lastInput, nextInput, parentDom, lifecycle, childContext, isSVG, isRecycling);\r\n                    if (hasComponentDidUpdate && instance.componentDidUpdate) {\r\n                        instance.componentDidUpdate(lastProps, lastState);\r\n                    }\r\n                    if (!isNull(options.afterUpdate)) {\r\n                        options.afterUpdate(nextVNode);\r\n                    }\r\n                    if (options.findDOMNodeEnabled) {\r\n                        componentToDOMNodeMap.set(instance, nextInput.dom);\r\n                    }\r\n                }\r\n                nextVNode.dom = nextInput.dom;\r\n            }\r\n            instance._updating = false;\r\n        }\r\n        else {\r\n            var shouldUpdate = true;\r\n            var lastProps$1 = lastVNode.props;\r\n            var nextHooks = nextVNode.ref;\r\n            var nextHooksDefined = !isNullOrUndef(nextHooks);\r\n            var lastInput$1 = lastVNode.children;\r\n            var nextInput$1 = lastInput$1;\r\n            nextVNode.dom = lastVNode.dom;\r\n            nextVNode.children = lastInput$1;\r\n            if (lastKey !== nextKey) {\r\n                shouldUpdate = true;\r\n            }\r\n            else {\r\n                if (nextHooksDefined &&\r\n                    !isNullOrUndef(nextHooks.onComponentShouldUpdate)) {\r\n                    shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps$1, nextProps);\r\n                }\r\n            }\r\n            if (shouldUpdate !== false) {\r\n                if (nextHooksDefined &&\r\n                    !isNullOrUndef(nextHooks.onComponentWillUpdate)) {\r\n                    nextHooks.onComponentWillUpdate(lastProps$1, nextProps);\r\n                }\r\n                nextInput$1 = nextType(nextProps, context);\r\n                if (isInvalid(nextInput$1)) {\r\n                    nextInput$1 = createVoidVNode();\r\n                }\r\n                else if (isStringOrNumber(nextInput$1) && nextInput$1 !== NO_OP) {\r\n                    nextInput$1 = createTextVNode(nextInput$1, null);\r\n                }\r\n                else if (isArray(nextInput$1)) {\r\n                    if (false) {\r\n                        throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n                    }\r\n                    throwError();\r\n                }\r\n                else if (isObject(nextInput$1)) {\r\n                    if (!isNull(nextInput$1.dom)) {\r\n                        nextInput$1 = directClone(nextInput$1);\r\n                    }\r\n                }\r\n                if (nextInput$1 !== NO_OP) {\r\n                    patch(lastInput$1, nextInput$1, parentDom, lifecycle, context, isSVG, isRecycling);\r\n                    nextVNode.children = nextInput$1;\r\n                    if (nextHooksDefined &&\r\n                        !isNullOrUndef(nextHooks.onComponentDidUpdate)) {\r\n                        nextHooks.onComponentDidUpdate(lastProps$1, nextProps);\r\n                    }\r\n                    nextVNode.dom = nextInput$1.dom;\r\n                }\r\n            }\r\n            if (nextInput$1.flags & 28 /* Component */) {\r\n                nextInput$1.parentVNode = nextVNode;\r\n            }\r\n            else if (lastInput$1.flags & 28 /* Component */) {\r\n                lastInput$1.parentVNode = nextVNode;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction patchText(lastVNode, nextVNode) {\r\n    var nextText = nextVNode.children;\r\n    var dom = lastVNode.dom;\r\n    nextVNode.dom = dom;\r\n    if (lastVNode.children !== nextText) {\r\n        dom.nodeValue = nextText;\r\n    }\r\n}\r\nfunction patchVoid(lastVNode, nextVNode) {\r\n    nextVNode.dom = lastVNode.dom;\r\n}\r\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var lastChildrenLength = lastChildren.length;\r\n    var nextChildrenLength = nextChildren.length;\r\n    var commonLength = lastChildrenLength > nextChildrenLength\r\n        ? nextChildrenLength\r\n        : lastChildrenLength;\r\n    var i = 0;\r\n    for (; i < commonLength; i++) {\r\n        var nextChild = nextChildren[i];\r\n        if (nextChild.dom) {\r\n            nextChild = nextChildren[i] = directClone(nextChild);\r\n        }\r\n        patch(lastChildren[i], nextChild, dom, lifecycle, context, isSVG, isRecycling);\r\n    }\r\n    if (lastChildrenLength < nextChildrenLength) {\r\n        for (i = commonLength; i < nextChildrenLength; i++) {\r\n            var nextChild$1 = nextChildren[i];\r\n            if (nextChild$1.dom) {\r\n                nextChild$1 = nextChildren[i] = directClone(nextChild$1);\r\n            }\r\n            appendChild(dom, mount(nextChild$1, null, lifecycle, context, isSVG));\r\n        }\r\n    }\r\n    else if (nextChildrenLength === 0) {\r\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\r\n    }\r\n    else if (lastChildrenLength > nextChildrenLength) {\r\n        for (i = commonLength; i < lastChildrenLength; i++) {\r\n            unmount(lastChildren[i], dom, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction patchKeyedChildren(a, b, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var aLength = a.length;\r\n    var bLength = b.length;\r\n    var aEnd = aLength - 1;\r\n    var bEnd = bLength - 1;\r\n    var aStart = 0;\r\n    var bStart = 0;\r\n    var i;\r\n    var j;\r\n    var aNode;\r\n    var bNode;\r\n    var nextNode;\r\n    var nextPos;\r\n    var node;\r\n    if (aLength === 0) {\r\n        if (bLength > 0) {\r\n            mountArrayChildren(b, dom, lifecycle, context, isSVG);\r\n        }\r\n        return;\r\n    }\r\n    else if (bLength === 0) {\r\n        removeAllChildren(dom, a, lifecycle, isRecycling);\r\n        return;\r\n    }\r\n    var aStartNode = a[aStart];\r\n    var bStartNode = b[bStart];\r\n    var aEndNode = a[aEnd];\r\n    var bEndNode = b[bEnd];\r\n    if (bStartNode.dom) {\r\n        b[bStart] = bStartNode = directClone(bStartNode);\r\n    }\r\n    if (bEndNode.dom) {\r\n        b[bEnd] = bEndNode = directClone(bEndNode);\r\n    }\r\n    // Step 1\r\n    /* eslint no-constant-condition: 0 */\r\n    outer: while (true) {\r\n        // Sync nodes with the same key at the beginning.\r\n        while (aStartNode.key === bStartNode.key) {\r\n            patch(aStartNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            aStart++;\r\n            bStart++;\r\n            if (aStart > aEnd || bStart > bEnd) {\r\n                break outer;\r\n            }\r\n            aStartNode = a[aStart];\r\n            bStartNode = b[bStart];\r\n            if (bStartNode.dom) {\r\n                b[bStart] = bStartNode = directClone(bStartNode);\r\n            }\r\n        }\r\n        // Sync nodes with the same key at the end.\r\n        while (aEndNode.key === bEndNode.key) {\r\n            patch(aEndNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            aEnd--;\r\n            bEnd--;\r\n            if (aStart > aEnd || bStart > bEnd) {\r\n                break outer;\r\n            }\r\n            aEndNode = a[aEnd];\r\n            bEndNode = b[bEnd];\r\n            if (bEndNode.dom) {\r\n                b[bEnd] = bEndNode = directClone(bEndNode);\r\n            }\r\n        }\r\n        // Move and sync nodes from right to left.\r\n        if (aEndNode.key === bStartNode.key) {\r\n            patch(aEndNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            insertOrAppend(dom, bStartNode.dom, aStartNode.dom);\r\n            aEnd--;\r\n            bStart++;\r\n            aEndNode = a[aEnd];\r\n            bStartNode = b[bStart];\r\n            if (bStartNode.dom) {\r\n                b[bStart] = bStartNode = directClone(bStartNode);\r\n            }\r\n            continue;\r\n        }\r\n        // Move and sync nodes from left to right.\r\n        if (aStartNode.key === bEndNode.key) {\r\n            patch(aStartNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            nextPos = bEnd + 1;\r\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n            insertOrAppend(dom, bEndNode.dom, nextNode);\r\n            aStart++;\r\n            bEnd--;\r\n            aStartNode = a[aStart];\r\n            bEndNode = b[bEnd];\r\n            if (bEndNode.dom) {\r\n                b[bEnd] = bEndNode = directClone(bEndNode);\r\n            }\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    if (aStart > aEnd) {\r\n        if (bStart <= bEnd) {\r\n            nextPos = bEnd + 1;\r\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n            while (bStart <= bEnd) {\r\n                node = b[bStart];\r\n                if (node.dom) {\r\n                    b[bStart] = node = directClone(node);\r\n                }\r\n                bStart++;\r\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n            }\r\n        }\r\n    }\r\n    else if (bStart > bEnd) {\r\n        while (aStart <= aEnd) {\r\n            unmount(a[aStart++], dom, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n    else {\r\n        aLength = aEnd - aStart + 1;\r\n        bLength = bEnd - bStart + 1;\r\n        var sources = new Array(bLength);\r\n        // Mark all nodes as inserted.\r\n        for (i = 0; i < bLength; i++) {\r\n            sources[i] = -1;\r\n        }\r\n        var moved = false;\r\n        var pos = 0;\r\n        var patched = 0;\r\n        // When sizes are small, just loop them through\r\n        if (bLength <= 4 || aLength * bLength <= 16) {\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLength) {\r\n                    for (j = bStart; j <= bEnd; j++) {\r\n                        bNode = b[j];\r\n                        if (aNode.key === bNode.key) {\r\n                            sources[j - bStart] = i;\r\n                            if (pos > j) {\r\n                                moved = true;\r\n                            }\r\n                            else {\r\n                                pos = j;\r\n                            }\r\n                            if (bNode.dom) {\r\n                                b[j] = bNode = directClone(bNode);\r\n                            }\r\n                            patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\r\n                            patched++;\r\n                            a[i] = null;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var keyIndex = new Map();\r\n            // Map keys by their index in array\r\n            for (i = bStart; i <= bEnd; i++) {\r\n                keyIndex.set(b[i].key, i);\r\n            }\r\n            // Try to patch same keys\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLength) {\r\n                    j = keyIndex.get(aNode.key);\r\n                    if (!isUndefined(j)) {\r\n                        bNode = b[j];\r\n                        sources[j - bStart] = i;\r\n                        if (pos > j) {\r\n                            moved = true;\r\n                        }\r\n                        else {\r\n                            pos = j;\r\n                        }\r\n                        if (bNode.dom) {\r\n                            b[j] = bNode = directClone(bNode);\r\n                        }\r\n                        patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\r\n                        patched++;\r\n                        a[i] = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // fast-path: if nothing patched remove all old and add all new\r\n        if (aLength === a.length && patched === 0) {\r\n            removeAllChildren(dom, a, lifecycle, isRecycling);\r\n            while (bStart < bLength) {\r\n                node = b[bStart];\r\n                if (node.dom) {\r\n                    b[bStart] = node = directClone(node);\r\n                }\r\n                bStart++;\r\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), null);\r\n            }\r\n        }\r\n        else {\r\n            i = aLength - patched;\r\n            while (i > 0) {\r\n                aNode = a[aStart++];\r\n                if (!isNull(aNode)) {\r\n                    unmount(aNode, dom, lifecycle, true, isRecycling);\r\n                    i--;\r\n                }\r\n            }\r\n            if (moved) {\r\n                var seq = lis_algorithm(sources);\r\n                j = seq.length - 1;\r\n                for (i = bLength - 1; i >= 0; i--) {\r\n                    if (sources[i] === -1) {\r\n                        pos = i + bStart;\r\n                        node = b[pos];\r\n                        if (node.dom) {\r\n                            b[pos] = node = directClone(node);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                        insertOrAppend(dom, mount(node, dom, lifecycle, context, isSVG), nextNode);\r\n                    }\r\n                    else {\r\n                        if (j < 0 || i !== seq[j]) {\r\n                            pos = i + bStart;\r\n                            node = b[pos];\r\n                            nextPos = pos + 1;\r\n                            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                            insertOrAppend(dom, node.dom, nextNode);\r\n                        }\r\n                        else {\r\n                            j--;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (patched !== bLength) {\r\n                // when patched count doesn't match b length we need to insert those new ones\r\n                // loop backwards so we can use insertBefore\r\n                for (i = bLength - 1; i >= 0; i--) {\r\n                    if (sources[i] === -1) {\r\n                        pos = i + bStart;\r\n                        node = b[pos];\r\n                        if (node.dom) {\r\n                            b[pos] = node = directClone(node);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n// // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction lis_algorithm(arr) {\r\n    var p = arr.slice(0);\r\n    var result = [0];\r\n    var i;\r\n    var j;\r\n    var u;\r\n    var v;\r\n    var c;\r\n    var len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var arrI = arr[i];\r\n        if (arrI === -1) {\r\n            continue;\r\n        }\r\n        j = result[result.length - 1];\r\n        if (arr[j] < arrI) {\r\n            p[i] = j;\r\n            result.push(i);\r\n            continue;\r\n        }\r\n        u = 0;\r\n        v = result.length - 1;\r\n        while (u < v) {\r\n            c = ((u + v) / 2) | 0;\r\n            if (arr[result[c]] < arrI) {\r\n                u = c + 1;\r\n            }\r\n            else {\r\n                v = c;\r\n            }\r\n        }\r\n        if (arrI < arr[result[u]]) {\r\n            if (u > 0) {\r\n                p[i] = result[u - 1];\r\n            }\r\n            result[u] = i;\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\r\nfunction isAttrAnEvent(attr) {\r\n    return attr[0] === \"o\" && attr[1] === \"n\";\r\n}\r\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue) {\r\n    if (lastValue !== nextValue) {\r\n        if (skipProps.has(prop) || (hasControlledValue && prop === \"value\")) {\r\n            return;\r\n        }\r\n        else if (booleanProps.has(prop)) {\r\n            prop = prop === \"autoFocus\" ? prop.toLowerCase() : prop;\r\n            dom[prop] = !!nextValue;\r\n        }\r\n        else if (strictProps.has(prop)) {\r\n            var value = isNullOrUndef(nextValue) ? \"\" : nextValue;\r\n            if (dom[prop] !== value) {\r\n                dom[prop] = value;\r\n            }\r\n        }\r\n        else if (isAttrAnEvent(prop)) {\r\n            patchEvent(prop, lastValue, nextValue, dom);\r\n        }\r\n        else if (isNullOrUndef(nextValue)) {\r\n            dom.removeAttribute(prop);\r\n        }\r\n        else if (prop === \"style\") {\r\n            patchStyle(lastValue, nextValue, dom);\r\n        }\r\n        else if (prop === \"dangerouslySetInnerHTML\") {\r\n            var lastHtml = lastValue && lastValue.__html;\r\n            var nextHtml = nextValue && nextValue.__html;\r\n            if (lastHtml !== nextHtml) {\r\n                if (!isNullOrUndef(nextHtml)) {\r\n                    dom.innerHTML = nextHtml;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // We optimize for NS being boolean. Its 99.9% time false\r\n            if (isSVG && namespaces.has(prop)) {\r\n                // If we end up in this path we can read property again\r\n                dom.setAttributeNS(namespaces.get(prop), prop, nextValue);\r\n            }\r\n            else {\r\n                dom.setAttribute(prop, nextValue);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction patchEvent(name, lastValue, nextValue, dom) {\r\n    if (lastValue !== nextValue) {\r\n        if (delegatedEvents.has(name)) {\r\n            handleEvent(name, lastValue, nextValue, dom);\r\n        }\r\n        else {\r\n            var nameLowerCase = name.toLowerCase();\r\n            var domEvent = dom[nameLowerCase];\r\n            // if the function is wrapped, that means it's been controlled by a wrapper\r\n            if (domEvent && domEvent.wrapped) {\r\n                return;\r\n            }\r\n            if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {\r\n                var linkEvent = nextValue.event;\r\n                if (linkEvent && isFunction(linkEvent)) {\r\n                    dom[nameLowerCase] = function (e) {\r\n                        linkEvent(nextValue.data, e);\r\n                    };\r\n                }\r\n                else {\r\n                    if (false) {\r\n                        throwError((\"an event on a VNode \\\"\" + name + \"\\\". was not a function or a valid linkEvent.\"));\r\n                    }\r\n                    throwError();\r\n                }\r\n            }\r\n            else {\r\n                dom[nameLowerCase] = nextValue;\r\n            }\r\n        }\r\n    }\r\n}\r\n// We are assuming here that we come from patchProp routine\r\n// -nextAttrValue cannot be null or undefined\r\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\r\n    var domStyle = dom.style;\r\n    var style;\r\n    var value;\r\n    if (isString(nextAttrValue)) {\r\n        domStyle.cssText = nextAttrValue;\r\n        return;\r\n    }\r\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\r\n        for (style in nextAttrValue) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            value = nextAttrValue[style];\r\n            if (value !== lastAttrValue[style]) {\r\n                domStyle[style] = !isNumber(value) || isUnitlessNumber.has(style)\r\n                    ? value\r\n                    : value + \"px\";\r\n            }\r\n        }\r\n        for (style in lastAttrValue) {\r\n            if (isNullOrUndef(nextAttrValue[style])) {\r\n                domStyle[style] = \"\";\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (style in nextAttrValue) {\r\n            value = nextAttrValue[style];\r\n            domStyle[style] = !isNumber(value) || isUnitlessNumber.has(style)\r\n                ? value\r\n                : value + \"px\";\r\n        }\r\n    }\r\n}\r\nfunction removeProp(prop, lastValue, dom, nextFlags) {\r\n    if (prop === \"value\") {\r\n        // When removing value of select element, it needs to be set to null instead empty string, because empty string is valid value for option which makes that option selected\r\n        // MS IE/Edge don't follow html spec for textArea and input elements and we need to set empty string to value in those cases to avoid \"null\" and \"undefined\" texts\r\n        dom.value = nextFlags & 2048 /* SelectElement */ ? null : \"\";\r\n    }\r\n    else if (prop === \"style\") {\r\n        dom.removeAttribute(\"style\");\r\n    }\r\n    else if (isAttrAnEvent(prop)) {\r\n        handleEvent(prop, lastValue, null, dom);\r\n    }\r\n    else {\r\n        dom.removeAttribute(prop);\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction mount(vNode, parentDom, lifecycle, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 3970 /* Element */) {\r\n        return mountElement(vNode, parentDom, lifecycle, context, isSVG);\r\n    }\r\n    else if (flags & 28 /* Component */) {\r\n        return mountComponent(vNode, parentDom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    else if (flags & 4096 /* Void */) {\r\n        return mountVoid(vNode, parentDom);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        return mountText(vNode, parentDom);\r\n    }\r\n    else {\r\n        if (false) {\r\n            if (typeof vNode === \"object\") {\r\n                throwError((\"mount() received an object that's not a valid VNode, you should stringify it first. Object: \\\"\" + (JSON.stringify(vNode)) + \"\\\".\"));\r\n            }\r\n            else {\r\n                throwError((\"mount() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\r\n            }\r\n        }\r\n        throwError();\r\n    }\r\n}\r\nfunction mountText(vNode, parentDom) {\r\n    var dom = document.createTextNode(vNode.children);\r\n    vNode.dom = dom;\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountVoid(vNode, parentDom) {\r\n    var dom = document.createTextNode(\"\");\r\n    vNode.dom = dom;\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountElement(vNode, parentDom, lifecycle, context, isSVG) {\r\n    if (options.recyclingEnabled) {\r\n        var dom$1 = recycleElement(vNode, lifecycle, context, isSVG);\r\n        if (!isNull(dom$1)) {\r\n            if (!isNull(parentDom)) {\r\n                appendChild(parentDom, dom$1);\r\n            }\r\n            return dom$1;\r\n        }\r\n    }\r\n    var flags = vNode.flags;\r\n    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;\r\n    var dom = documentCreateElement(vNode.type, isSVG);\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var ref = vNode.ref;\r\n    vNode.dom = dom;\r\n    if (!isInvalid(children)) {\r\n        if (isStringOrNumber(children)) {\r\n            setTextContent(dom, children);\r\n        }\r\n        else {\r\n            var childrenIsSVG = isSVG === true && vNode.type !== \"foreignObject\";\r\n            if (isArray(children)) {\r\n                mountArrayChildren(children, dom, lifecycle, context, childrenIsSVG);\r\n            }\r\n            else if (isVNode(children)) {\r\n                mount(children, dom, lifecycle, context, childrenIsSVG);\r\n            }\r\n        }\r\n    }\r\n    if (!isNull(props)) {\r\n        var hasControlledValue = false;\r\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\r\n        if (isFormElement) {\r\n            hasControlledValue = isControlledFormElement(props);\r\n        }\r\n        for (var prop in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\r\n        }\r\n        if (isFormElement) {\r\n            processElement(flags, vNode, dom, props, true, hasControlledValue);\r\n        }\r\n    }\r\n    if (className !== null) {\r\n        if (isSVG) {\r\n            dom.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n    }\r\n    if (!isNull(ref)) {\r\n        mountRef(dom, ref, lifecycle);\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountArrayChildren(children, dom, lifecycle, context, isSVG) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        var child = children[i];\r\n        // Verify can string/number be here. might cause de-opt. - Normalization takes care of it.\r\n        if (!isInvalid(child)) {\r\n            if (child.dom) {\r\n                children[i] = child = directClone(child);\r\n            }\r\n            mount(children[i], dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n}\r\nfunction mountComponent(vNode, parentDom, lifecycle, context, isSVG, isClass) {\r\n    if (options.recyclingEnabled) {\r\n        var dom$1 = recycleComponent(vNode, lifecycle, context, isSVG);\r\n        if (!isNull(dom$1)) {\r\n            if (!isNull(parentDom)) {\r\n                appendChild(parentDom, dom$1);\r\n            }\r\n            return dom$1;\r\n        }\r\n    }\r\n    var type = vNode.type;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var ref = vNode.ref;\r\n    var dom;\r\n    if (isClass) {\r\n        var instance = createClassComponentInstance(vNode, type, props, context, isSVG, lifecycle);\r\n        var input = instance._lastInput;\r\n        instance._vNode = vNode;\r\n        vNode.dom = dom = mount(input, null, lifecycle, instance._childContext, isSVG);\r\n        if (!isNull(parentDom)) {\r\n            appendChild(parentDom, dom);\r\n        }\r\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\r\n        instance._updating = false;\r\n        if (options.findDOMNodeEnabled) {\r\n            componentToDOMNodeMap.set(instance, dom);\r\n        }\r\n    }\r\n    else {\r\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\r\n        vNode.dom = dom = mount(input$1, null, lifecycle, context, isSVG);\r\n        vNode.children = input$1;\r\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\r\n        if (!isNull(parentDom)) {\r\n            appendChild(parentDom, dom);\r\n        }\r\n    }\r\n    return dom;\r\n}\r\nfunction mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {\r\n    if (ref) {\r\n        if (isFunction(ref)) {\r\n            ref(instance);\r\n        }\r\n        else {\r\n            if (false) {\r\n                if (isStringOrNumber(ref)) {\r\n                    throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n                }\r\n                else if (isObject(ref) && vNode.flags & 4 /* ComponentClass */) {\r\n                    throwError(\"functional component lifecycle events are not supported on ES2015 class components.\");\r\n                }\r\n                else {\r\n                    throwError((\"a bad value for \\\"ref\\\" was used on component: \\\"\" + (JSON.stringify(ref)) + \"\\\"\"));\r\n                }\r\n            }\r\n            throwError();\r\n        }\r\n    }\r\n    var hasDidMount = !isUndefined(instance.componentDidMount);\r\n    var afterMount = options.afterMount;\r\n    if (hasDidMount || !isNull(afterMount)) {\r\n        lifecycle.addListener((function () {\r\n            instance._updating = true;\r\n            if (afterMount) {\r\n                afterMount(vNode);\r\n            }\r\n            if (hasDidMount) {\r\n                instance.componentDidMount();\r\n            }\r\n            instance._updating = false;\r\n        }));\r\n    }\r\n}\r\nfunction mountFunctionalComponentCallbacks(ref, dom, lifecycle) {\r\n    if (ref) {\r\n        if (!isNullOrUndef(ref.onComponentWillMount)) {\r\n            ref.onComponentWillMount();\r\n        }\r\n        if (!isNullOrUndef(ref.onComponentDidMount)) {\r\n            lifecycle.addListener((function () { return ref.onComponentDidMount(dom); }));\r\n        }\r\n    }\r\n}\r\nfunction mountRef(dom, value, lifecycle) {\r\n    if (isFunction(value)) {\r\n        lifecycle.addListener((function () { return value(dom); }));\r\n    }\r\n    else {\r\n        if (isInvalid(value)) {\r\n            return;\r\n        }\r\n        if (false) {\r\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n        }\r\n        throwError();\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n// We need EMPTY_OBJ defined in one place.\r\n// Its used for comparison so we cant inline it into shared\r\nvar EMPTY_OBJ = {};\r\nif (false) {\r\n    Object.freeze(EMPTY_OBJ);\r\n}\r\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\r\n    if (isUndefined(context)) {\r\n        context = EMPTY_OBJ; // Context should not be mutable\r\n    }\r\n    var instance = new Component(props, context);\r\n    vNode.children = instance;\r\n    instance._blockSetState = false;\r\n    instance.context = context;\r\n    if (instance.props === EMPTY_OBJ) {\r\n        instance.props = props;\r\n    }\r\n    // setState callbacks must fire after render is done when called from componentWillReceiveProps or componentWillMount\r\n    instance._lifecycle = lifecycle;\r\n    instance._unmounted = false;\r\n    instance._pendingSetState = true;\r\n    instance._isSVG = isSVG;\r\n    if (!isNullOrUndef(instance.componentWillMount)) {\r\n        instance._blockRender = true;\r\n        instance.componentWillMount();\r\n        instance._blockRender = false;\r\n    }\r\n    var childContext;\r\n    if (!isNullOrUndef(instance.getChildContext)) {\r\n        childContext = instance.getChildContext();\r\n    }\r\n    if (isNullOrUndef(childContext)) {\r\n        instance._childContext = context;\r\n    }\r\n    else {\r\n        instance._childContext = combineFrom(context, childContext);\r\n    }\r\n    if (!isNull(options.beforeRender)) {\r\n        options.beforeRender(instance);\r\n    }\r\n    var input = instance.render(props, instance.state, context);\r\n    if (!isNull(options.afterRender)) {\r\n        options.afterRender(instance);\r\n    }\r\n    if (isArray(input)) {\r\n        if (false) {\r\n            throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n        }\r\n        throwError();\r\n    }\r\n    else if (isInvalid(input)) {\r\n        input = createVoidVNode();\r\n    }\r\n    else if (isStringOrNumber(input)) {\r\n        input = createTextVNode(input, null);\r\n    }\r\n    else {\r\n        if (input.dom) {\r\n            input = directClone(input);\r\n        }\r\n        if (input.flags & 28 /* Component */) {\r\n            // if we have an input that is also a component, we run into a tricky situation\r\n            // where the root vNode needs to always have the correct DOM entry\r\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\r\n            // we can optimise this in the future, but this gets us out of a lot of issues\r\n            input.parentVNode = vNode;\r\n        }\r\n    }\r\n    instance._pendingSetState = false;\r\n    instance._lastInput = input;\r\n    return instance;\r\n}\r\nfunction replaceLastChildAndUnmount(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    replaceVNode(parentDom, mount(nextInput, null, lifecycle, context, isSVG), lastInput, lifecycle, isRecycling);\r\n}\r\nfunction replaceVNode(parentDom, dom, vNode, lifecycle, isRecycling) {\r\n    unmount(vNode, null, lifecycle, false, isRecycling);\r\n    replaceChild(parentDom, dom, vNode.dom);\r\n}\r\nfunction createFunctionalComponentInput(vNode, component, props, context) {\r\n    var input = component(props, context);\r\n    if (isArray(input)) {\r\n        if (false) {\r\n            throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n        }\r\n        throwError();\r\n    }\r\n    else if (isInvalid(input)) {\r\n        input = createVoidVNode();\r\n    }\r\n    else if (isStringOrNumber(input)) {\r\n        input = createTextVNode(input, null);\r\n    }\r\n    else {\r\n        if (input.dom) {\r\n            input = directClone(input);\r\n        }\r\n        if (input.flags & 28 /* Component */) {\r\n            // if we have an input that is also a component, we run into a tricky situation\r\n            // where the root vNode needs to always have the correct DOM entry\r\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\r\n            // we can optimise this in the future, but this gets us out of a lot of issues\r\n            input.parentVNode = vNode;\r\n        }\r\n    }\r\n    return input;\r\n}\r\nfunction setTextContent(dom, text) {\r\n    if (text !== \"\") {\r\n        dom.textContent = text;\r\n    }\r\n    else {\r\n        dom.appendChild(document.createTextNode(\"\"));\r\n    }\r\n}\r\nfunction updateTextContent(dom, text) {\r\n    dom.firstChild.nodeValue = text;\r\n}\r\nfunction appendChild(parentDom, dom) {\r\n    parentDom.appendChild(dom);\r\n}\r\nfunction insertOrAppend(parentDom, newNode, nextNode) {\r\n    if (isNullOrUndef(nextNode)) {\r\n        appendChild(parentDom, newNode);\r\n    }\r\n    else {\r\n        parentDom.insertBefore(newNode, nextNode);\r\n    }\r\n}\r\nfunction documentCreateElement(tag, isSVG) {\r\n    if (isSVG === true) {\r\n        return document.createElementNS(svgNS, tag);\r\n    }\r\n    else {\r\n        return document.createElement(tag);\r\n    }\r\n}\r\nfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    unmount(lastNode, null, lifecycle, false, isRecycling);\r\n    var dom = mount(nextNode, null, lifecycle, context, isSVG);\r\n    nextNode.dom = dom;\r\n    replaceChild(parentDom, dom, lastNode.dom);\r\n}\r\nfunction replaceChild(parentDom, nextDom, lastDom) {\r\n    if (!parentDom) {\r\n        parentDom = lastDom.parentNode;\r\n    }\r\n    parentDom.replaceChild(nextDom, lastDom);\r\n}\r\nfunction removeChild(parentDom, dom) {\r\n    parentDom.removeChild(dom);\r\n}\r\nfunction removeAllChildren(dom, children, lifecycle, isRecycling) {\r\n    if (!options.recyclingEnabled || (options.recyclingEnabled && !isRecycling)) {\r\n        removeChildren(null, children, lifecycle, isRecycling);\r\n    }\r\n    dom.textContent = \"\";\r\n}\r\nfunction removeChildren(dom, children, lifecycle, isRecycling) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        var child = children[i];\r\n        if (!isInvalid(child)) {\r\n            unmount(child, dom, lifecycle, true, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction isKeyed(lastChildren, nextChildren) {\r\n    return (nextChildren.length > 0 &&\r\n        !isNullOrUndef(nextChildren[0]) &&\r\n        !isNullOrUndef(nextChildren[0].key) &&\r\n        lastChildren.length > 0 &&\r\n        !isNullOrUndef(lastChildren[0]) &&\r\n        !isNullOrUndef(lastChildren[0].key));\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction VNode(children, className, flags, key, props, ref, type) {\r\n    this.children = children;\r\n    this.className = className;\r\n    this.dom = null;\r\n    this.flags = flags;\r\n    this.key = key;\r\n    this.props = props;\r\n    this.ref = ref;\r\n    this.type = type;\r\n}\r\n/**\r\n * Creates virtual node\r\n * @param {number} flags\r\n * @param {string|Function|null} type\r\n * @param {string|null=} className\r\n * @param {object=} children\r\n * @param {object=} props\r\n * @param {*=} key\r\n * @param {object|Function=} ref\r\n * @param {boolean=} noNormalise\r\n * @returns {VNode} returns new virtual node\r\n */\r\nfunction createVNode(flags, type, className, children, props, key, ref, noNormalise) {\r\n    if (flags & 16 /* ComponentUnknown */) {\r\n        flags = isStatefulComponent(type)\r\n            ? 4 /* ComponentClass */\r\n            : 8 /* ComponentFunction */;\r\n    }\r\n    var vNode = new VNode(children === void 0 ? null : children, className === void 0 ? null : className, flags, key === void 0 ? null : key, props === void 0 ? null : props, ref === void 0 ? null : ref, type);\r\n    if (noNormalise !== true) {\r\n        normalize(vNode);\r\n    }\r\n    if (options.createVNode !== null) {\r\n        options.createVNode(vNode);\r\n    }\r\n    return vNode;\r\n}\r\nfunction directClone(vNodeToClone) {\r\n    var newVNode;\r\n    var flags = vNodeToClone.flags;\r\n    if (flags & 28 /* Component */) {\r\n        var props;\r\n        var propsToClone = vNodeToClone.props;\r\n        if (isNull(propsToClone)) {\r\n            props = EMPTY_OBJ;\r\n        }\r\n        else {\r\n            props = {};\r\n            for (var key in propsToClone) {\r\n                props[key] = propsToClone[key];\r\n            }\r\n        }\r\n        newVNode = createVNode(flags, vNodeToClone.type, null, null, props, vNodeToClone.key, vNodeToClone.ref, true);\r\n        var newProps = newVNode.props;\r\n        var newChildren = newProps.children;\r\n        // we need to also clone component children that are in props\r\n        // as the children may also have been hoisted\r\n        if (newChildren) {\r\n            if (isArray(newChildren)) {\r\n                var len = newChildren.length;\r\n                if (len > 0) {\r\n                    var tmpArray = [];\r\n                    for (var i = 0; i < len; i++) {\r\n                        var child = newChildren[i];\r\n                        if (isStringOrNumber(child)) {\r\n                            tmpArray.push(child);\r\n                        }\r\n                        else if (!isInvalid(child) && isVNode(child)) {\r\n                            tmpArray.push(directClone(child));\r\n                        }\r\n                    }\r\n                    newProps.children = tmpArray;\r\n                }\r\n            }\r\n            else if (isVNode(newChildren)) {\r\n                newProps.children = directClone(newChildren);\r\n            }\r\n        }\r\n        newVNode.children = null;\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        var children = vNodeToClone.children;\r\n        var props$1;\r\n        var propsToClone$1 = vNodeToClone.props;\r\n        if (propsToClone$1 === null) {\r\n            props$1 = EMPTY_OBJ;\r\n        }\r\n        else {\r\n            props$1 = {};\r\n            for (var key$1 in propsToClone$1) {\r\n                props$1[key$1] = propsToClone$1[key$1];\r\n            }\r\n        }\r\n        newVNode = createVNode(flags, vNodeToClone.type, vNodeToClone.className, children, props$1, vNodeToClone.key, vNodeToClone.ref, !children);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        newVNode = createTextVNode(vNodeToClone.children, vNodeToClone.key);\r\n    }\r\n    return newVNode;\r\n}\r\n/*\r\n directClone is preferred over cloneVNode and used internally also.\r\n This function makes Inferno backwards compatible.\r\n And can be tree-shaked by modern bundlers\r\n\n Would be nice to combine this with directClone but could not do it without breaking change\r\n */\r\n/**\r\n * Clones given virtual node by creating new instance of it\r\n * @param {VNode} vNodeToClone virtual node to be cloned\r\n * @param {Props=} props additional props for new virtual node\r\n * @param {...*} _children new children for new virtual node\r\n * @returns {VNode} new virtual node\r\n */\r\nfunction cloneVNode(vNodeToClone, props) {\n    var _children = [], len$2 = arguments.length - 2;\n    while ( len$2-- > 0 ) _children[ len$2 ] = arguments[ len$2 + 2 ];\n\r\n    var children = _children;\r\n    var childrenLen = _children.length;\r\n    if (childrenLen > 0 && !isUndefined(_children[0])) {\r\n        if (!props) {\r\n            props = {};\r\n        }\r\n        if (childrenLen === 1) {\r\n            children = _children[0];\r\n        }\r\n        if (!isUndefined(children)) {\r\n            props.children = children;\r\n        }\r\n    }\r\n    var newVNode;\r\n    if (isArray(vNodeToClone)) {\r\n        var tmpArray = [];\r\n        for (var i = 0, len = vNodeToClone.length; i < len; i++) {\r\n            tmpArray.push(directClone(vNodeToClone[i]));\r\n        }\r\n        newVNode = tmpArray;\r\n    }\r\n    else {\r\n        var flags = vNodeToClone.flags;\r\n        var className = vNodeToClone.className;\r\n        var key = vNodeToClone.key;\r\n        var ref = vNodeToClone.ref;\r\n        if (props) {\r\n            if (props.hasOwnProperty(\"className\")) {\r\n                className = props.className;\r\n            }\r\n            if (props.hasOwnProperty(\"ref\")) {\r\n                ref = props.ref;\r\n            }\r\n            if (props.hasOwnProperty(\"key\")) {\r\n                key = props.key;\r\n            }\r\n        }\r\n        if (flags & 28 /* Component */) {\r\n            newVNode = createVNode(flags, vNodeToClone.type, className, null, !vNodeToClone.props && !props\r\n                ? EMPTY_OBJ\r\n                : combineFrom(vNodeToClone.props, props), key, ref, true);\r\n            var newProps = newVNode.props;\r\n            if (newProps) {\r\n                var newChildren = newProps.children;\r\n                // we need to also clone component children that are in props\r\n                // as the children may also have been hoisted\r\n                if (newChildren) {\r\n                    if (isArray(newChildren)) {\r\n                        var len$1 = newChildren.length;\r\n                        if (len$1 > 0) {\r\n                            var tmpArray$1 = [];\r\n                            for (var i$1 = 0; i$1 < len$1; i$1++) {\r\n                                var child = newChildren[i$1];\r\n                                if (isStringOrNumber(child)) {\r\n                                    tmpArray$1.push(child);\r\n                                }\r\n                                else if (!isInvalid(child) && isVNode(child)) {\r\n                                    tmpArray$1.push(directClone(child));\r\n                                }\r\n                            }\r\n                            newProps.children = tmpArray$1;\r\n                        }\r\n                    }\r\n                    else if (isVNode(newChildren)) {\r\n                        newProps.children = directClone(newChildren);\r\n                    }\r\n                }\r\n            }\r\n            newVNode.children = null;\r\n        }\r\n        else if (flags & 3970 /* Element */) {\r\n            children = props && !isUndefined(props.children)\r\n                ? props.children\r\n                : vNodeToClone.children;\r\n            newVNode = createVNode(flags, vNodeToClone.type, className, children, !vNodeToClone.props && !props\r\n                ? EMPTY_OBJ\r\n                : combineFrom(vNodeToClone.props, props), key, ref, false);\r\n        }\r\n        else if (flags & 1 /* Text */) {\r\n            newVNode = createTextVNode(vNodeToClone.children, key);\r\n        }\r\n    }\r\n    return newVNode;\r\n}\r\nfunction createVoidVNode() {\r\n    return createVNode(4096 /* Void */, null);\r\n}\r\nfunction createTextVNode(text, key) {\r\n    return createVNode(1 /* Text */, null, null, text, null, key);\r\n}\r\nfunction isVNode(o) {\r\n    return !!o.flags;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction applyKey(key, vNode) {\r\n    vNode.key = key;\r\n    return vNode;\r\n}\r\nfunction applyKeyIfMissing(key, vNode) {\r\n    if (isNumber(key)) {\r\n        key = \".\" + key;\r\n    }\r\n    if (isNull(vNode.key) || vNode.key[0] === \".\") {\r\n        return applyKey(key, vNode);\r\n    }\r\n    return vNode;\r\n}\r\nfunction applyKeyPrefix(key, vNode) {\r\n    vNode.key = key + vNode.key;\r\n    return vNode;\r\n}\r\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\r\n    for (var len = nodes.length; index < len; index++) {\r\n        var n = nodes[index];\r\n        var key = currentKey + \".\" + index;\r\n        if (!isInvalid(n)) {\r\n            if (isArray(n)) {\r\n                _normalizeVNodes(n, result, 0, key);\r\n            }\r\n            else {\r\n                if (isStringOrNumber(n)) {\r\n                    n = createTextVNode(n, null);\r\n                }\r\n                else if ((isVNode(n) && n.dom) || (n.key && n.key[0] === \".\")) {\r\n                    n = directClone(n);\r\n                }\r\n                if (isNull(n.key) || n.key[0] === \".\") {\r\n                    n = applyKey(key, n);\r\n                }\r\n                else {\r\n                    n = applyKeyPrefix(currentKey, n);\r\n                }\r\n                result.push(n);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction normalizeVNodes(nodes) {\r\n    var newNodes;\r\n    // we assign $ which basically means we've flagged this array for future note\r\n    // if it comes back again, we need to clone it, as people are using it\r\n    // in an immutable way\r\n    // tslint:disable\r\n    if (nodes[\"$\"] === true) {\r\n        nodes = nodes.slice();\r\n    }\r\n    else {\r\n        nodes[\"$\"] = true;\r\n    }\r\n    // tslint:enable\r\n    for (var i = 0, len = nodes.length; i < len; i++) {\r\n        var n = nodes[i];\r\n        if (isInvalid(n) || isArray(n)) {\r\n            var result = (newNodes || nodes).slice(0, i);\r\n            _normalizeVNodes(nodes, result, i, \"\");\r\n            return result;\r\n        }\r\n        else if (isStringOrNumber(n)) {\r\n            if (!newNodes) {\r\n                newNodes = nodes.slice(0, i);\r\n            }\r\n            newNodes.push(applyKeyIfMissing(i, createTextVNode(n, null)));\r\n        }\r\n        else if ((isVNode(n) && n.dom !== null) ||\r\n            (isNull(n.key) && (n.flags & 64 /* HasNonKeyedChildren */) === 0)) {\r\n            if (!newNodes) {\r\n                newNodes = nodes.slice(0, i);\r\n            }\r\n            newNodes.push(applyKeyIfMissing(i, directClone(n)));\r\n        }\r\n        else if (newNodes) {\r\n            newNodes.push(applyKeyIfMissing(i, directClone(n)));\r\n        }\r\n    }\r\n    return newNodes || nodes;\r\n}\r\nfunction normalizeChildren(children) {\r\n    if (isArray(children)) {\r\n        return normalizeVNodes(children);\r\n    }\r\n    else if (isVNode(children) && children.dom !== null) {\r\n        return directClone(children);\r\n    }\r\n    return children;\r\n}\r\nfunction normalizeProps(vNode, props, children) {\r\n    if (vNode.flags & 3970 /* Element */) {\r\n        if (isNullOrUndef(children) && props.hasOwnProperty(\"children\")) {\r\n            vNode.children = props.children;\r\n        }\r\n        if (props.hasOwnProperty(\"className\")) {\r\n            vNode.className = props.className || null;\r\n            delete props.className;\r\n        }\r\n    }\r\n    if (props.hasOwnProperty(\"ref\")) {\r\n        vNode.ref = props.ref;\r\n        delete props.ref;\r\n    }\r\n    if (props.hasOwnProperty(\"key\")) {\r\n        vNode.key = props.key;\r\n        delete props.key;\r\n    }\r\n}\r\nfunction getFlagsForElementVnode(type) {\r\n    if (type === \"svg\") {\r\n        return 128 /* SvgElement */;\r\n    }\r\n    else if (type === \"input\") {\r\n        return 512 /* InputElement */;\r\n    }\r\n    else if (type === \"select\") {\r\n        return 2048 /* SelectElement */;\r\n    }\r\n    else if (type === \"textarea\") {\r\n        return 1024 /* TextareaElement */;\r\n    }\r\n    else if (type === \"media\") {\r\n        return 256 /* MediaElement */;\r\n    }\r\n    return 2 /* HtmlElement */;\r\n}\r\nfunction normalize(vNode) {\r\n    var props = vNode.props;\r\n    var children = vNode.children;\r\n    // convert a wrongly created type back to element\r\n    // Primitive node doesn't have defaultProps, only Component\r\n    if (vNode.flags & 28 /* Component */) {\r\n        // set default props\r\n        var type = vNode.type;\r\n        var defaultProps = type.defaultProps;\r\n        if (!isNullOrUndef(defaultProps)) {\r\n            if (!props) {\r\n                props = vNode.props = defaultProps; // Create new object if only defaultProps given\r\n            }\r\n            else {\r\n                for (var prop in defaultProps) {\r\n                    if (isUndefined(props[prop])) {\r\n                        props[prop] = defaultProps[prop];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (isString(type)) {\r\n            vNode.flags = getFlagsForElementVnode(type);\r\n            if (props && props.children) {\r\n                vNode.children = props.children;\r\n                children = props.children;\r\n            }\r\n        }\r\n    }\r\n    if (props) {\r\n        normalizeProps(vNode, props, children);\r\n        if (!isInvalid(props.children)) {\r\n            props.children = normalizeChildren(props.children);\r\n        }\r\n    }\r\n    if (!isInvalid(children)) {\r\n        vNode.children = normalizeChildren(children);\r\n    }\r\n    if (false) {\r\n        // This code will be stripped out from production CODE\r\n        // It helps users to track errors in their applications.\r\n        var verifyKeys = function (vNodes) {\r\n            var keyValues = vNodes.map((function (vnode) {\r\n                return vnode.key;\r\n            }));\r\n            keyValues.some((function (item, idx) {\r\n                var hasDuplicate = keyValues.indexOf(item) !== idx;\r\n                if (hasDuplicate) {\r\n                    warning(\"Inferno normalisation(...): Encountered two children with same key, all keys must be unique within its siblings. Duplicated key is:\" +\r\n                        item);\r\n                }\r\n                return hasDuplicate;\r\n            }));\r\n        };\r\n        if (vNode.children && Array.isArray(vNode.children)) {\r\n            verifyKeys(vNode.children);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * Links given data to event as first parameter\r\n * @param {*} data data to be linked, it will be available in function as first parameter\r\n * @param {Function} event Function to be called when event occurs\r\n * @returns {{data: *, event: Function}}\r\n */\r\nfunction linkEvent(data, event) {\r\n    if (isFunction(event)) {\r\n        return { data: data, event: event };\r\n    }\r\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/* tslint:disable:object-literal-sort-keys */\r\nif (false) {\r\n    /* tslint:disable-next-line:no-empty */\r\n    var testFunc = function testFn() { };\r\n    if ((testFunc.name || testFunc.toString()).indexOf(\"testFn\") ===\r\n        -1) {\r\n        warning(\"It looks like you're using a minified copy of the development build \" +\r\n            \"of Inferno. When deploying Inferno apps to production, make sure to use \" +\r\n            \"the production build which skips development warnings and is faster. \" +\r\n            \"See http://infernojs.org for more details.\");\r\n    }\r\n}\r\nvar version = \"3.6.1\";\r\n// we duplicate it so it plays nicely with different module loading systems\r\nvar index = {\r\n    EMPTY_OBJ: EMPTY_OBJ,\r\n    NO_OP: NO_OP,\r\n    cloneVNode: cloneVNode,\r\n    createRenderer: createRenderer,\r\n    createVNode: createVNode,\r\n    findDOMNode: findDOMNode,\r\n    getFlagsForElementVnode: getFlagsForElementVnode,\r\n    internal_DOMNodeMap: componentToDOMNodeMap,\r\n    internal_isUnitlessNumber: isUnitlessNumber,\r\n    internal_normalize: normalize,\r\n    internal_patch: patch,\r\n    linkEvent: linkEvent,\r\n    options: options,\r\n    render: render,\r\n    version: version\r\n};\n\nexports['default'] = index;\nexports.EMPTY_OBJ = EMPTY_OBJ;\nexports.NO_OP = NO_OP;\nexports.cloneVNode = cloneVNode;\nexports.createRenderer = createRenderer;\nexports.createVNode = createVNode;\nexports.findDOMNode = findDOMNode;\nexports.getFlagsForElementVnode = getFlagsForElementVnode;\nexports.internal_DOMNodeMap = componentToDOMNodeMap;\nexports.internal_isUnitlessNumber = isUnitlessNumber;\nexports.internal_normalize = normalize;\nexports.internal_patch = patch;\nexports.linkEvent = linkEvent;\nexports.options = options;\nexports.render = render;\nexports.version = version;\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 0-c46c3e7a.min.js","import Inferno from 'inferno';\n\nconst testImportLog = function() {\n\tconsole.log('working');\n}\n\nexport {testImportLog};\n\n\n// WEBPACK FOOTER //\n// ./client/scripts/testImport.js","module.exports = require('./dist').default;\nmodule.exports.default = module.exports;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/inferno/index.js\n// module id = 7\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * @module Inferno-Shared\r\n */ /** TypeDoc Comment */\r\n/**\r\n * @module Inferno-Shared\r\n */ /** TypeDoc Comment */ var NO_OP = '$NO_OP';\r\nvar ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';\r\n// This should be boolean and not reference to window.document\r\nvar isBrowser = !!(typeof window !== 'undefined' && window.document);\r\n// this is MUCH faster than .constructor === Array and instanceof Array\r\n// in Node 7 and the later versions of V8, slower in older versions though\r\nvar isArray = Array.isArray;\r\nfunction isStatefulComponent(o) {\r\n    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);\r\n}\r\nfunction isStringOrNumber(o) {\r\n    var type = typeof o;\r\n    return type === 'string' || type === 'number';\r\n}\r\nfunction isNullOrUndef(o) {\r\n    return isUndefined(o) || isNull(o);\r\n}\r\nfunction isInvalid(o) {\r\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\r\n}\r\nfunction isFunction(o) {\r\n    return typeof o === 'function';\r\n}\r\nfunction isString(o) {\r\n    return typeof o === 'string';\r\n}\r\nfunction isNumber(o) {\r\n    return typeof o === 'number';\r\n}\r\nfunction isNull(o) {\r\n    return o === null;\r\n}\r\nfunction isTrue(o) {\r\n    return o === true;\r\n}\r\nfunction isUndefined(o) {\r\n    return o === void 0;\r\n}\r\nfunction isObject(o) {\r\n    return typeof o === 'object';\r\n}\r\nfunction throwError(message) {\r\n    if (!message) {\r\n        message = ERROR_MSG;\r\n    }\r\n    throw new Error((\"Inferno Error: \" + message));\r\n}\r\nfunction warning(message) {\r\n    // tslint:disable-next-line:no-console\r\n    console.warn(message);\r\n}\r\nfunction combineFrom(first, second) {\r\n    var out = {};\r\n    if (first) {\r\n        for (var key in first) {\r\n            out[key] = first[key];\r\n        }\r\n    }\r\n    if (second) {\r\n        for (var key$1 in second) {\r\n            out[key$1] = second[key$1];\r\n        }\r\n    }\r\n    return out;\r\n}\r\nfunction Lifecycle() {\r\n    this.listeners = [];\r\n}\r\nLifecycle.prototype.addListener = function addListener(callback) {\r\n    this.listeners.push(callback);\r\n};\r\nLifecycle.prototype.trigger = function trigger() {\r\n    var listeners = this.listeners;\r\n    var listener;\r\n    // We need to remove current listener from array when calling it, because more listeners might be added\r\n    while (listener = listeners.shift()) {\r\n        listener();\r\n    }\r\n};\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar options = {\r\n    afterMount: null,\r\n    afterRender: null,\r\n    afterUpdate: null,\r\n    beforeRender: null,\r\n    beforeUnmount: null,\r\n    createVNode: null,\r\n    findDOMNodeEnabled: false,\r\n    recyclingEnabled: false,\r\n    roots: []\r\n};\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */ var xlinkNS = \"http://www.w3.org/1999/xlink\";\r\nvar xmlNS = \"http://www.w3.org/XML/1998/namespace\";\r\nvar svgNS = \"http://www.w3.org/2000/svg\";\r\nvar strictProps = new Set();\r\nstrictProps.add(\"volume\");\r\nstrictProps.add(\"defaultChecked\");\r\nvar booleanProps = new Set();\r\nbooleanProps.add(\"muted\");\r\nbooleanProps.add(\"scoped\");\r\nbooleanProps.add(\"loop\");\r\nbooleanProps.add(\"open\");\r\nbooleanProps.add(\"checked\");\r\nbooleanProps.add(\"default\");\r\nbooleanProps.add(\"capture\");\r\nbooleanProps.add(\"disabled\");\r\nbooleanProps.add(\"readOnly\");\r\nbooleanProps.add(\"required\");\r\nbooleanProps.add(\"autoplay\");\r\nbooleanProps.add(\"controls\");\r\nbooleanProps.add(\"seamless\");\r\nbooleanProps.add(\"reversed\");\r\nbooleanProps.add(\"allowfullscreen\");\r\nbooleanProps.add(\"novalidate\");\r\nbooleanProps.add(\"hidden\");\r\nbooleanProps.add(\"autoFocus\");\r\nbooleanProps.add(\"selected\");\r\nvar namespaces = new Map();\r\nnamespaces.set(\"xlink:href\", xlinkNS);\r\nnamespaces.set(\"xlink:arcrole\", xlinkNS);\r\nnamespaces.set(\"xlink:actuate\", xlinkNS);\r\nnamespaces.set(\"xlink:show\", xlinkNS);\r\nnamespaces.set(\"xlink:role\", xlinkNS);\r\nnamespaces.set(\"xlink:title\", xlinkNS);\r\nnamespaces.set(\"xlink:type\", xlinkNS);\r\nnamespaces.set(\"xml:base\", xmlNS);\r\nnamespaces.set(\"xml:lang\", xmlNS);\r\nnamespaces.set(\"xml:space\", xmlNS);\r\nvar isUnitlessNumber = new Set();\r\nisUnitlessNumber.add(\"animationIterationCount\");\r\nisUnitlessNumber.add(\"borderImageOutset\");\r\nisUnitlessNumber.add(\"borderImageSlice\");\r\nisUnitlessNumber.add(\"borderImageWidth\");\r\nisUnitlessNumber.add(\"boxFlex\");\r\nisUnitlessNumber.add(\"boxFlexGroup\");\r\nisUnitlessNumber.add(\"boxOrdinalGroup\");\r\nisUnitlessNumber.add(\"columnCount\");\r\nisUnitlessNumber.add(\"flex\");\r\nisUnitlessNumber.add(\"flexGrow\");\r\nisUnitlessNumber.add(\"flexPositive\");\r\nisUnitlessNumber.add(\"flexShrink\");\r\nisUnitlessNumber.add(\"flexNegative\");\r\nisUnitlessNumber.add(\"flexOrder\");\r\nisUnitlessNumber.add(\"gridRow\");\r\nisUnitlessNumber.add(\"gridColumn\");\r\nisUnitlessNumber.add(\"fontWeight\");\r\nisUnitlessNumber.add(\"lineClamp\");\r\nisUnitlessNumber.add(\"lineHeight\");\r\nisUnitlessNumber.add(\"opacity\");\r\nisUnitlessNumber.add(\"order\");\r\nisUnitlessNumber.add(\"orphans\");\r\nisUnitlessNumber.add(\"tabSize\");\r\nisUnitlessNumber.add(\"widows\");\r\nisUnitlessNumber.add(\"zIndex\");\r\nisUnitlessNumber.add(\"zoom\");\r\nisUnitlessNumber.add(\"fillOpacity\");\r\nisUnitlessNumber.add(\"floodOpacity\");\r\nisUnitlessNumber.add(\"stopOpacity\");\r\nisUnitlessNumber.add(\"strokeDasharray\");\r\nisUnitlessNumber.add(\"strokeDashoffset\");\r\nisUnitlessNumber.add(\"strokeMiterlimit\");\r\nisUnitlessNumber.add(\"strokeOpacity\");\r\nisUnitlessNumber.add(\"strokeWidth\");\r\nvar skipProps = new Set();\r\nskipProps.add(\"children\");\r\nskipProps.add(\"childrenType\");\r\nskipProps.add(\"defaultValue\");\r\nskipProps.add(\"ref\");\r\nskipProps.add(\"key\");\r\nskipProps.add(\"checked\");\r\nskipProps.add(\"multiple\");\r\nvar delegatedEvents = new Set();\r\ndelegatedEvents.add(\"onClick\");\r\ndelegatedEvents.add(\"onMouseDown\");\r\ndelegatedEvents.add(\"onMouseUp\");\r\ndelegatedEvents.add(\"onMouseMove\");\r\ndelegatedEvents.add(\"onSubmit\");\r\ndelegatedEvents.add(\"onDblClick\");\r\ndelegatedEvents.add(\"onKeyDown\");\r\ndelegatedEvents.add(\"onKeyUp\");\r\ndelegatedEvents.add(\"onKeyPress\");\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar isiOS = isBrowser && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);\r\nvar delegatedEvents$1 = new Map();\r\nfunction handleEvent(name, lastEvent, nextEvent, dom) {\r\n    var delegatedRoots = delegatedEvents$1.get(name);\r\n    if (nextEvent) {\r\n        if (!delegatedRoots) {\r\n            delegatedRoots = { items: new Map(), docEvent: null };\r\n            delegatedRoots.docEvent = attachEventToDocument(name, delegatedRoots);\r\n            delegatedEvents$1.set(name, delegatedRoots);\r\n        }\r\n        if (!lastEvent) {\r\n            if (isiOS && name === 'onClick') {\r\n                trapClickOnNonInteractiveElement(dom);\r\n            }\r\n        }\r\n        delegatedRoots.items.set(dom, nextEvent);\r\n    }\r\n    else if (delegatedRoots) {\r\n        var items = delegatedRoots.items;\r\n        if (items.delete(dom)) {\r\n            // If any items were deleted, check if listener need to be removed\r\n            if (items.size === 0) {\r\n                document.removeEventListener(normalizeEventName(name), delegatedRoots.docEvent);\r\n                delegatedEvents$1.delete(name);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction dispatchEvent(event, target, items, count, isClick, eventData) {\r\n    var eventsToTrigger = items.get(target);\r\n    if (eventsToTrigger) {\r\n        count--;\r\n        // linkEvent object\r\n        eventData.dom = target;\r\n        if (eventsToTrigger.event) {\r\n            eventsToTrigger.event(eventsToTrigger.data, event);\r\n        }\r\n        else {\r\n            eventsToTrigger(event);\r\n        }\r\n        if (event.cancelBubble) {\r\n            return;\r\n        }\r\n    }\r\n    if (count > 0) {\r\n        var parentDom = target.parentNode;\r\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\r\n        // because the event listener is on document.body\r\n        // Don't process clicks on disabled elements\r\n        if (parentDom === null || (isClick && parentDom.nodeType === 1 && parentDom.disabled)) {\r\n            return;\r\n        }\r\n        dispatchEvent(event, parentDom, items, count, isClick, eventData);\r\n    }\r\n}\r\nfunction normalizeEventName(name) {\r\n    return name.substr(2).toLowerCase();\r\n}\r\nfunction stopPropagation() {\r\n    this.cancelBubble = true;\r\n    this.stopImmediatePropagation();\r\n}\r\nfunction attachEventToDocument(name, delegatedRoots) {\r\n    var docEvent = function (event) {\r\n        var count = delegatedRoots.items.size;\r\n        if (count > 0) {\r\n            event.stopPropagation = stopPropagation;\r\n            // Event data needs to be object to save reference to currentTarget getter\r\n            var eventData = {\r\n                dom: document\r\n            };\r\n            try {\r\n                Object.defineProperty(event, 'currentTarget', {\r\n                    configurable: true,\r\n                    get: function get() {\r\n                        return eventData.dom;\r\n                    }\r\n                });\r\n            }\r\n            catch (e) { }\r\n            dispatchEvent(event, event.target, delegatedRoots.items, count, event.type === 'click', eventData);\r\n        }\r\n    };\r\n    document.addEventListener(normalizeEventName(name), docEvent);\r\n    return docEvent;\r\n}\r\n// tslint:disable-next-line:no-empty\r\nfunction emptyFn() { }\r\nfunction trapClickOnNonInteractiveElement(dom) {\r\n    // Mobile Safari does not fire properly bubble click events on\r\n    // non-interactive elements, which means delegated click listeners do not\r\n    // fire. The workaround for this bug involves attaching an empty click\r\n    // listener on the target node.\r\n    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\r\n    // Just set it using the onclick property so that we don't have to manage any\r\n    // bookkeeping for it. Not sure if we need to clear it when the listener is\r\n    // removed.\r\n    // TODO: Only do this for the relevant Safaris maybe?\r\n    dom.onclick = emptyFn;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction isCheckedType(type) {\r\n    return type === 'checkbox' || type === 'radio';\r\n}\r\nfunction onTextInputChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    var previousValue = props.value;\r\n    if (props.onInput) {\r\n        var event = props.onInput;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.oninput) {\r\n        props.oninput(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue(newProps, dom);\r\n    }\r\n}\r\nfunction wrappedOnChange(e) {\r\n    var props = this.vNode.props || EMPTY_OBJ;\r\n    var event = props.onChange;\r\n    if (event.event) {\r\n        event.event(event.data, e);\r\n    }\r\n    else {\r\n        event(e);\r\n    }\r\n}\r\nfunction onCheckboxChange(e) {\r\n    e.stopPropagation(); // This click should not propagate its for internal use\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    if (props.onClick) {\r\n        var event = props.onClick;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.onclick) {\r\n        props.onclick(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    applyValue(newProps, dom);\r\n}\r\nfunction processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue(nextPropsOrEmpty, dom);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            if (isCheckedType(nextPropsOrEmpty.type)) {\r\n                dom.onclick = onCheckboxChange;\r\n                dom.onclick.wrapped = true;\r\n            }\r\n            else {\r\n                dom.oninput = onTextInputChange;\r\n                dom.oninput.wrapped = true;\r\n            }\r\n            if (nextPropsOrEmpty.onChange) {\r\n                dom.onchange = wrappedOnChange;\r\n                dom.onchange.wrapped = true;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction applyValue(nextPropsOrEmpty, dom) {\r\n    var type = nextPropsOrEmpty.type;\r\n    var value = nextPropsOrEmpty.value;\r\n    var checked = nextPropsOrEmpty.checked;\r\n    var multiple = nextPropsOrEmpty.multiple;\r\n    var defaultValue = nextPropsOrEmpty.defaultValue;\r\n    var hasValue = !isNullOrUndef(value);\r\n    if (type && type !== dom.type) {\r\n        dom.setAttribute('type', type);\r\n    }\r\n    if (multiple && multiple !== dom.multiple) {\r\n        dom.multiple = multiple;\r\n    }\r\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\r\n        dom.defaultValue = defaultValue + '';\r\n    }\r\n    if (isCheckedType(type)) {\r\n        if (hasValue) {\r\n            dom.value = value;\r\n        }\r\n        if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n    else {\r\n        if (hasValue && dom.value !== value) {\r\n            dom.defaultValue = value;\r\n            dom.value = value;\r\n        }\r\n        else if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction updateChildOptionGroup(vNode, value) {\r\n    var type = vNode.type;\r\n    if (type === 'optgroup') {\r\n        var children = vNode.children;\r\n        if (isArray(children)) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOption(children[i], value);\r\n            }\r\n        }\r\n        else if (isVNode(children)) {\r\n            updateChildOption(children, value);\r\n        }\r\n    }\r\n    else {\r\n        updateChildOption(vNode, value);\r\n    }\r\n}\r\nfunction updateChildOption(vNode, value) {\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    // we do this as multiple may have changed\r\n    dom.value = props.value;\r\n    if ((isArray(value) && value.indexOf(props.value) !== -1) || props.value === value) {\r\n        dom.selected = true;\r\n    }\r\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\r\n        dom.selected = props.selected || false;\r\n    }\r\n}\r\nfunction onSelectChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    var previousValue = props.value;\r\n    if (props.onChange) {\r\n        var event = props.onChange;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.onchange) {\r\n        props.onchange(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue$1(newVNode, dom, newProps, false);\r\n    }\r\n}\r\nfunction processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue$1(vNode, dom, nextPropsOrEmpty, mounting);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            dom.onchange = onSelectChange;\r\n            dom.onchange.wrapped = true;\r\n        }\r\n    }\r\n}\r\nfunction applyValue$1(vNode, dom, nextPropsOrEmpty, mounting) {\r\n    if (nextPropsOrEmpty.multiple !== dom.multiple) {\r\n        dom.multiple = nextPropsOrEmpty.multiple;\r\n    }\r\n    var children = vNode.children;\r\n    if (!isInvalid(children)) {\r\n        var value = nextPropsOrEmpty.value;\r\n        if (mounting && isNullOrUndef(value)) {\r\n            value = nextPropsOrEmpty.defaultValue;\r\n        }\r\n        if (isArray(children)) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOptionGroup(children[i], value);\r\n            }\r\n        }\r\n        else if (isVNode(children)) {\r\n            updateChildOptionGroup(children, value);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction wrappedOnChange$1(e) {\r\n    var props = this.vNode.props || EMPTY_OBJ;\r\n    var event = props.onChange;\r\n    if (event.event) {\r\n        event.event(event.data, e);\r\n    }\r\n    else {\r\n        event(e);\r\n    }\r\n}\r\nfunction onTextareaInputChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var previousValue = props.value;\r\n    if (props.onInput) {\r\n        var event = props.onInput;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.oninput) {\r\n        props.oninput(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue$2(newVNode, vNode.dom, false);\r\n    }\r\n}\r\nfunction processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue$2(nextPropsOrEmpty, dom, mounting);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            dom.oninput = onTextareaInputChange;\r\n            dom.oninput.wrapped = true;\r\n            if (nextPropsOrEmpty.onChange) {\r\n                dom.onchange = wrappedOnChange$1;\r\n                dom.onchange.wrapped = true;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction applyValue$2(nextPropsOrEmpty, dom, mounting) {\r\n    var value = nextPropsOrEmpty.value;\r\n    var domValue = dom.value;\r\n    if (isNullOrUndef(value)) {\r\n        if (mounting) {\r\n            var defaultValue = nextPropsOrEmpty.defaultValue;\r\n            if (!isNullOrUndef(defaultValue)) {\r\n                if (defaultValue !== domValue) {\r\n                    dom.defaultValue = defaultValue;\r\n                    dom.value = defaultValue;\r\n                }\r\n            }\r\n            else if (domValue !== '') {\r\n                dom.defaultValue = '';\r\n                dom.value = '';\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        /* There is value so keep it controlled */\r\n        if (domValue !== value) {\r\n            dom.defaultValue = value;\r\n            dom.value = value;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * There is currently no support for switching same input between controlled and nonControlled\r\n * If that ever becomes a real issue, then re design controlled elements\r\n * Currently user must choose either controlled or non-controlled and stick with that\r\n */\r\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    if (flags & 512 /* InputElement */) {\r\n        processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n    if (flags & 2048 /* SelectElement */) {\r\n        processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n    if (flags & 1024 /* TextareaElement */) {\r\n        processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n}\r\nfunction isControlledFormElement(nextPropsOrEmpty) {\r\n    return (nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type)) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction normalizeChildNodes(parentDom) {\r\n    var dom = parentDom.firstChild;\r\n    while (dom) {\r\n        if (dom.nodeType === 8) {\r\n            if (dom.data === \"!\") {\r\n                var placeholder = document.createTextNode(\"\");\r\n                parentDom.replaceChild(placeholder, dom);\r\n                dom = dom.nextSibling;\r\n            }\r\n            else {\r\n                var lastDom = dom.previousSibling;\r\n                parentDom.removeChild(dom);\r\n                dom = lastDom || parentDom.firstChild;\r\n            }\r\n        }\r\n        else {\r\n            dom = dom.nextSibling;\r\n        }\r\n    }\r\n}\r\nfunction hydrateComponent(vNode, dom, lifecycle, context, isSVG, isClass) {\r\n    var type = vNode.type;\r\n    var ref = vNode.ref;\r\n    vNode.dom = dom;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    if (isClass) {\r\n        var _isSVG = dom.namespaceURI === svgNS;\r\n        var instance = createClassComponentInstance(vNode, type, props, context, _isSVG, lifecycle);\r\n        var input = instance._lastInput;\r\n        instance._vNode = vNode;\r\n        hydrate(input, dom, lifecycle, instance._childContext, _isSVG);\r\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\r\n        instance._updating = false; // Mount finished allow going sync\r\n        if (options.findDOMNodeEnabled) {\r\n            componentToDOMNodeMap.set(instance, dom);\r\n        }\r\n    }\r\n    else {\r\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\r\n        hydrate(input$1, dom, lifecycle, context, isSVG);\r\n        vNode.children = input$1;\r\n        vNode.dom = input$1.dom;\r\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\r\n    }\r\n    return dom;\r\n}\r\nfunction hydrateElement(vNode, dom, lifecycle, context, isSVG) {\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var flags = vNode.flags;\r\n    var ref = vNode.ref;\r\n    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;\r\n    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warning(\"Inferno hydration: Server-side markup doesn't match client-side markup or Initial render target is not empty\");\r\n        }\r\n        var newDom = mountElement(vNode, null, lifecycle, context, isSVG);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n        return newDom;\r\n    }\r\n    vNode.dom = dom;\r\n    if (children) {\r\n        hydrateChildren(children, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (dom.firstChild !== null) {\r\n        dom.textContent = \"\"; // dom has content, but VNode has no children remove everything from DOM\r\n    }\r\n    if (props) {\r\n        var hasControlledValue = false;\r\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\r\n        if (isFormElement) {\r\n            hasControlledValue = isControlledFormElement(props);\r\n        }\r\n        for (var prop in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\r\n        }\r\n        if (isFormElement) {\r\n            processElement(flags, vNode, dom, props, true, hasControlledValue);\r\n        }\r\n    }\r\n    if (!isNullOrUndef(className)) {\r\n        if (isSVG) {\r\n            dom.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n    }\r\n    else {\r\n        if (dom.className !== \"\") {\r\n            dom.removeAttribute(\"class\");\r\n        }\r\n    }\r\n    if (ref) {\r\n        mountRef(dom, ref, lifecycle);\r\n    }\r\n    return dom;\r\n}\r\nfunction hydrateChildren(children, parentDom, lifecycle, context, isSVG) {\r\n    normalizeChildNodes(parentDom);\r\n    var dom = parentDom.firstChild;\r\n    if (isStringOrNumber(children)) {\r\n        if (!isNull(dom) && dom.nodeType === 3) {\r\n            if (dom.nodeValue !== children) {\r\n                dom.nodeValue = children;\r\n            }\r\n        }\r\n        else if (children) {\r\n            parentDom.textContent = children;\r\n        }\r\n        if (!isNull(dom)) {\r\n            dom = dom.nextSibling;\r\n        }\r\n    }\r\n    else if (isArray(children)) {\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            if (!isNull(child) && isObject(child)) {\r\n                if (!isNull(dom)) {\r\n                    var nextSibling = dom.nextSibling;\r\n                    hydrate(child, dom, lifecycle, context, isSVG);\r\n                    dom = nextSibling;\r\n                }\r\n                else {\r\n                    mount(child, parentDom, lifecycle, context, isSVG);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // It's VNode\r\n        if (!isNull(dom)) {\r\n            hydrate(children, dom, lifecycle, context, isSVG);\r\n            dom = dom.nextSibling;\r\n        }\r\n        else {\r\n            mount(children, parentDom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    // clear any other DOM nodes, there should be only a single entry for the root\r\n    while (dom) {\r\n        var nextSibling$1 = dom.nextSibling;\r\n        parentDom.removeChild(dom);\r\n        dom = nextSibling$1;\r\n    }\r\n}\r\nfunction hydrateText(vNode, dom) {\r\n    if (dom.nodeType !== 3) {\r\n        var newDom = mountText(vNode, null);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n        return newDom;\r\n    }\r\n    var text = vNode.children;\r\n    if (dom.nodeValue !== text) {\r\n        dom.nodeValue = text;\r\n    }\r\n    vNode.dom = dom;\r\n    return dom;\r\n}\r\nfunction hydrateVoid(vNode, dom) {\r\n    vNode.dom = dom;\r\n    return dom;\r\n}\r\nfunction hydrate(vNode, dom, lifecycle, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 28 /* Component */) {\r\n        hydrateComponent(vNode, dom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        hydrateElement(vNode, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        hydrateText(vNode, dom);\r\n    }\r\n    else if (flags & 4096 /* Void */) {\r\n        hydrateVoid(vNode, dom);\r\n    }\r\n    else {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError((\"hydrate() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\r\n        }\r\n        throwError();\r\n    }\r\n}\r\nfunction hydrateRoot(input, parentDom, lifecycle) {\r\n    if (!isNull(parentDom)) {\r\n        var dom = parentDom.firstChild;\r\n        if (!isNull(dom)) {\r\n            hydrate(input, dom, lifecycle, EMPTY_OBJ, false);\r\n            dom = parentDom.firstChild;\r\n            // clear any other DOM nodes, there should be only a single entry for the root\r\n            while ((dom = dom.nextSibling)) {\r\n                parentDom.removeChild(dom);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar componentPools = new Map();\r\nvar elementPools = new Map();\r\nfunction recycleElement(vNode, lifecycle, context, isSVG) {\r\n    var tag = vNode.type;\r\n    var pools = elementPools.get(tag);\r\n    if (!isUndefined(pools)) {\r\n        var key = vNode.key;\r\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\r\n        if (!isUndefined(pool)) {\r\n            var recycledVNode = pool.pop();\r\n            if (!isUndefined(recycledVNode)) {\r\n                patchElement(recycledVNode, vNode, null, lifecycle, context, isSVG, true);\r\n                return vNode.dom;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction poolElement(vNode) {\r\n    var tag = vNode.type;\r\n    var key = vNode.key;\r\n    var pools = elementPools.get(tag);\r\n    if (isUndefined(pools)) {\r\n        pools = {\r\n            keyed: new Map(),\r\n            nonKeyed: []\r\n        };\r\n        elementPools.set(tag, pools);\r\n    }\r\n    if (isNull(key)) {\r\n        pools.nonKeyed.push(vNode);\r\n    }\r\n    else {\r\n        var pool = pools.keyed.get(key);\r\n        if (isUndefined(pool)) {\r\n            pool = [];\r\n            pools.keyed.set(key, pool);\r\n        }\r\n        pool.push(vNode);\r\n    }\r\n}\r\nfunction recycleComponent(vNode, lifecycle, context, isSVG) {\r\n    var type = vNode.type;\r\n    var pools = componentPools.get(type);\r\n    if (!isUndefined(pools)) {\r\n        var key = vNode.key;\r\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\r\n        if (!isUndefined(pool)) {\r\n            var recycledVNode = pool.pop();\r\n            if (!isUndefined(recycledVNode)) {\r\n                var flags = vNode.flags;\r\n                var failed = patchComponent(recycledVNode, vNode, null, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0, true);\r\n                if (!failed) {\r\n                    return vNode.dom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction poolComponent(vNode) {\r\n    var hooks = vNode.ref;\r\n    var nonRecycleHooks = hooks &&\r\n        (hooks.onComponentWillMount ||\r\n            hooks.onComponentWillUnmount ||\r\n            hooks.onComponentDidMount ||\r\n            hooks.onComponentWillUpdate ||\r\n            hooks.onComponentDidUpdate);\r\n    if (nonRecycleHooks) {\r\n        return;\r\n    }\r\n    var type = vNode.type;\r\n    var key = vNode.key;\r\n    var pools = componentPools.get(type);\r\n    if (isUndefined(pools)) {\r\n        pools = {\r\n            keyed: new Map(),\r\n            nonKeyed: []\r\n        };\r\n        componentPools.set(type, pools);\r\n    }\r\n    if (isNull(key)) {\r\n        pools.nonKeyed.push(vNode);\r\n    }\r\n    else {\r\n        var pool = pools.keyed.get(key);\r\n        if (isUndefined(pool)) {\r\n            pool = [];\r\n            pools.keyed.set(key, pool);\r\n        }\r\n        pool.push(vNode);\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction unmount(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var flags = vNode.flags;\r\n    if (flags & 28 /* Component */) {\r\n        unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling);\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling);\r\n    }\r\n    else if (flags & (1 /* Text */ | 4096 /* Void */)) {\r\n        unmountVoidOrText(vNode, parentDom);\r\n    }\r\n}\r\nfunction unmountVoidOrText(vNode, parentDom) {\r\n    if (!isNull(parentDom)) {\r\n        removeChild(parentDom, vNode.dom);\r\n    }\r\n}\r\nfunction unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var instance = vNode.children;\r\n    var flags = vNode.flags;\r\n    var isStatefulComponent$$1 = flags & 4;\r\n    var ref = vNode.ref;\r\n    var dom = vNode.dom;\r\n    if (!isRecycling) {\r\n        if (isStatefulComponent$$1) {\r\n            if (!instance._unmounted) {\r\n                if (!isNull(options.beforeUnmount)) {\r\n                    options.beforeUnmount(vNode);\r\n                }\r\n                if (!isUndefined(instance.componentWillUnmount)) {\r\n                    instance.componentWillUnmount();\r\n                }\r\n                if (ref && !isRecycling) {\r\n                    ref(null);\r\n                }\r\n                instance._unmounted = true;\r\n                if (options.findDOMNodeEnabled) {\r\n                    componentToDOMNodeMap.delete(instance);\r\n                }\r\n                unmount(instance._lastInput, null, instance._lifecycle, false, isRecycling);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndef(ref)) {\r\n                if (!isNullOrUndef(ref.onComponentWillUnmount)) {\r\n                    ref.onComponentWillUnmount(dom);\r\n                }\r\n            }\r\n            unmount(instance, null, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n    if (parentDom) {\r\n        var lastInput = instance._lastInput;\r\n        if (isNullOrUndef(lastInput)) {\r\n            lastInput = instance;\r\n        }\r\n        removeChild(parentDom, dom);\r\n    }\r\n    if (options.recyclingEnabled &&\r\n        !isStatefulComponent$$1 &&\r\n        (parentDom || canRecycle)) {\r\n        poolComponent(vNode);\r\n    }\r\n}\r\nfunction unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var dom = vNode.dom;\r\n    var ref = vNode.ref;\r\n    var props = vNode.props;\r\n    if (ref && !isRecycling) {\r\n        unmountRef(ref);\r\n    }\r\n    var children = vNode.children;\r\n    if (!isNullOrUndef(children)) {\r\n        unmountChildren$1(children, lifecycle, isRecycling);\r\n    }\r\n    if (!isNull(props)) {\r\n        for (var name in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            if (props[name] !== null && isAttrAnEvent(name)) {\r\n                patchEvent(name, props[name], null, dom);\r\n                // We need to set this null, because same props otherwise come back if SCU returns false and we are recyling\r\n                props[name] = null;\r\n            }\r\n        }\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        removeChild(parentDom, dom);\r\n    }\r\n    if (options.recyclingEnabled && (parentDom || canRecycle)) {\r\n        poolElement(vNode);\r\n    }\r\n}\r\nfunction unmountChildren$1(children, lifecycle, isRecycling) {\r\n    if (isArray(children)) {\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            if (!isInvalid(child) && isObject(child)) {\r\n                unmount(child, null, lifecycle, false, isRecycling);\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(children)) {\r\n        unmount(children, null, lifecycle, false, isRecycling);\r\n    }\r\n}\r\nfunction unmountRef(ref) {\r\n    if (isFunction(ref)) {\r\n        ref(null);\r\n    }\r\n    else {\r\n        if (isInvalid(ref)) {\r\n            return;\r\n        }\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n        }\r\n        throwError();\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n// rather than use a Map, like we did before, we can use an array here\r\n// given there shouldn't be THAT many roots on the page, the difference\r\n// in performance is huge: https://esbench.com/bench/5802a691330ab09900a1a2da\r\nvar componentToDOMNodeMap = new Map();\r\nvar roots = options.roots;\r\n/**\r\n * When inferno.options.findDOMNOdeEnabled is true, this function will return DOM Node by component instance\r\n * @param ref Component instance\r\n * @returns {*|null} returns dom node\r\n */\r\nfunction findDOMNode(ref) {\r\n    if (!options.findDOMNodeEnabled) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError(\"findDOMNode() has been disabled, use Inferno.options.findDOMNodeEnabled = true; enabled findDOMNode(). Warning this can significantly impact performance!\");\r\n        }\r\n        throwError();\r\n    }\r\n    var dom = ref && ref.nodeType ? ref : null;\r\n    return componentToDOMNodeMap.get(ref) || dom;\r\n}\r\nfunction getRoot(dom) {\r\n    for (var i = 0, len = roots.length; i < len; i++) {\r\n        var root = roots[i];\r\n        if (root.dom === dom) {\r\n            return root;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction setRoot(dom, input, lifecycle) {\r\n    var root = {\r\n        dom: dom,\r\n        input: input,\r\n        lifecycle: lifecycle\r\n    };\r\n    roots.push(root);\r\n    return root;\r\n}\r\nfunction removeRoot(root) {\r\n    for (var i = 0, len = roots.length; i < len; i++) {\r\n        if (roots[i] === root) {\r\n            roots.splice(i, 1);\r\n            return;\r\n        }\r\n    }\r\n}\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    if (isBrowser && document.body === null) {\r\n        warning('Inferno warning: you cannot initialize inferno without \"document.body\". Wait on \"DOMContentLoaded\" event, add script to bottom of body, or use async/defer attributes on script tag.');\r\n    }\r\n}\r\nvar documentBody = isBrowser ? document.body : null;\r\n/**\r\n * Renders virtual node tree into parent node.\r\n * @param {VNode | null | string | number} input vNode to be rendered\r\n * @param parentDom DOM node which content will be replaced by virtual node\r\n * @returns {InfernoChildren} rendered virtual node\r\n */\r\nfunction render(input, parentDom) {\r\n    if (documentBody === parentDom) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError('you cannot render() to the \"document.body\". Use an empty element as a container instead.');\r\n        }\r\n        throwError();\r\n    }\r\n    if (input === NO_OP) {\r\n        return;\r\n    }\r\n    var root = getRoot(parentDom);\r\n    if (isNull(root)) {\r\n        var lifecycle = new Lifecycle();\r\n        if (!isInvalid(input)) {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            if (!hydrateRoot(input, parentDom, lifecycle)) {\r\n                mount(input, parentDom, lifecycle, EMPTY_OBJ, false);\r\n            }\r\n            root = setRoot(parentDom, input, lifecycle);\r\n            lifecycle.trigger();\r\n        }\r\n    }\r\n    else {\r\n        var lifecycle$1 = root.lifecycle;\r\n        lifecycle$1.listeners = [];\r\n        if (isNullOrUndef(input)) {\r\n            unmount(root.input, parentDom, lifecycle$1, false, false);\r\n            removeRoot(root);\r\n        }\r\n        else {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            patch(root.input, input, parentDom, lifecycle$1, EMPTY_OBJ, false, false);\r\n        }\r\n        root.input = input;\r\n        lifecycle$1.trigger();\r\n    }\r\n    if (root) {\r\n        var rootInput = root.input;\r\n        if (rootInput && rootInput.flags & 28 /* Component */) {\r\n            return rootInput.children;\r\n        }\r\n    }\r\n}\r\nfunction createRenderer(parentDom) {\r\n    return function renderer(lastInput, nextInput) {\r\n        if (!parentDom) {\r\n            parentDom = lastInput;\r\n        }\r\n        render(nextInput, parentDom);\r\n    };\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction patch(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    if (lastVNode !== nextVNode) {\r\n        var lastFlags = lastVNode.flags;\r\n        var nextFlags = nextVNode.flags;\r\n        if (nextFlags & 28 /* Component */) {\r\n            var isClass = (nextFlags & 4 /* ComponentClass */) > 0;\r\n            if (lastFlags & 28 /* Component */) {\r\n                patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, isClass), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 3970 /* Element */) {\r\n            if (lastFlags & 3970 /* Element */) {\r\n                patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountElement(nextVNode, null, lifecycle, context, isSVG), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 1 /* Text */) {\r\n            if (lastFlags & 1 /* Text */) {\r\n                patchText(lastVNode, nextVNode);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountText(nextVNode, null), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 4096 /* Void */) {\r\n            if (lastFlags & 4096 /* Void */) {\r\n                patchVoid(lastVNode, nextVNode);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountVoid(nextVNode, null), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else {\r\n            // Error case: mount new one replacing old one\r\n            replaceLastChildAndUnmount(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction unmountChildren(children, dom, lifecycle, isRecycling) {\r\n    if (isVNode(children)) {\r\n        unmount(children, dom, lifecycle, true, isRecycling);\r\n    }\r\n    else if (isArray(children)) {\r\n        removeAllChildren(dom, children, lifecycle, isRecycling);\r\n    }\r\n    else {\r\n        dom.textContent = \"\";\r\n    }\r\n}\r\nfunction patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    var nextTag = nextVNode.type;\r\n    var lastTag = lastVNode.type;\r\n    if (lastTag !== nextTag) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n    }\r\n    else {\r\n        var dom = lastVNode.dom;\r\n        var lastProps = lastVNode.props;\r\n        var nextProps = nextVNode.props;\r\n        var lastChildren = lastVNode.children;\r\n        var nextChildren = nextVNode.children;\r\n        var lastFlags = lastVNode.flags;\r\n        var nextFlags = nextVNode.flags;\r\n        var nextRef = nextVNode.ref;\r\n        var lastClassName = lastVNode.className;\r\n        var nextClassName = nextVNode.className;\r\n        nextVNode.dom = dom;\r\n        isSVG = isSVG || (nextFlags & 128 /* SvgElement */) > 0;\r\n        if (lastChildren !== nextChildren) {\r\n            var childrenIsSVG = isSVG === true && nextVNode.type !== \"foreignObject\";\r\n            patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, childrenIsSVG, isRecycling);\r\n        }\r\n        // inlined patchProps  -- starts --\r\n        if (lastProps !== nextProps) {\r\n            var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\r\n            var nextPropsOrEmpty = nextProps || EMPTY_OBJ;\r\n            var hasControlledValue = false;\r\n            if (nextPropsOrEmpty !== EMPTY_OBJ) {\r\n                var isFormElement = (nextFlags & 3584 /* FormElement */) > 0;\r\n                if (isFormElement) {\r\n                    hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\r\n                }\r\n                for (var prop in nextPropsOrEmpty) {\r\n                    // do not add a hasOwnProperty check here, it affects performance\r\n                    var nextValue = nextPropsOrEmpty[prop];\r\n                    var lastValue = lastPropsOrEmpty[prop];\r\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue);\r\n                }\r\n                if (isFormElement) {\r\n                    // When inferno is recycling form element, we need to process it like it would be mounting\r\n                    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, isRecycling, hasControlledValue);\r\n                }\r\n            }\r\n            if (lastPropsOrEmpty !== EMPTY_OBJ) {\r\n                for (var prop$1 in lastPropsOrEmpty) {\r\n                    // do not add a hasOwnProperty check here, it affects performance\r\n                    if (isNullOrUndef(nextPropsOrEmpty[prop$1]) &&\r\n                        !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\r\n                        removeProp(prop$1, lastPropsOrEmpty[prop$1], dom, nextFlags);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // inlined patchProps  -- ends --\r\n        if (lastClassName !== nextClassName) {\r\n            if (isNullOrUndef(nextClassName)) {\r\n                dom.removeAttribute(\"class\");\r\n            }\r\n            else {\r\n                if (isSVG) {\r\n                    dom.setAttribute(\"class\", nextClassName);\r\n                }\r\n                else {\r\n                    dom.className = nextClassName;\r\n                }\r\n            }\r\n        }\r\n        if (nextRef) {\r\n            if (lastVNode.ref !== nextRef || isRecycling) {\r\n                mountRef(dom, nextRef, lifecycle);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var patchArray = false;\r\n    var patchKeyed = false;\r\n    if (nextFlags & 64 /* HasNonKeyedChildren */) {\r\n        patchArray = true;\r\n    }\r\n    else if ((lastFlags & 32 /* HasKeyedChildren */) > 0 &&\r\n        (nextFlags & 32 /* HasKeyedChildren */) > 0) {\r\n        patchKeyed = true;\r\n        patchArray = true;\r\n    }\r\n    else if (isInvalid(nextChildren)) {\r\n        unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n    }\r\n    else if (isInvalid(lastChildren)) {\r\n        if (isStringOrNumber(nextChildren)) {\r\n            setTextContent(dom, nextChildren);\r\n        }\r\n        else {\r\n            if (isArray(nextChildren)) {\r\n                mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\r\n            }\r\n            else {\r\n                mount(nextChildren, dom, lifecycle, context, isSVG);\r\n            }\r\n        }\r\n    }\r\n    else if (isStringOrNumber(nextChildren)) {\r\n        if (isStringOrNumber(lastChildren)) {\r\n            updateTextContent(dom, nextChildren);\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            setTextContent(dom, nextChildren);\r\n        }\r\n    }\r\n    else if (isArray(nextChildren)) {\r\n        if (isArray(lastChildren)) {\r\n            patchArray = true;\r\n            if (isKeyed(lastChildren, nextChildren)) {\r\n                patchKeyed = true;\r\n            }\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    else if (isArray(lastChildren)) {\r\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\r\n        mount(nextChildren, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (isVNode(nextChildren)) {\r\n        if (isVNode(lastChildren)) {\r\n            patch(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            mount(nextChildren, dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    if (patchArray) {\r\n        if (patchKeyed) {\r\n            patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n        else {\r\n            patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling) {\r\n    var lastType = lastVNode.type;\r\n    var nextType = nextVNode.type;\r\n    var lastKey = lastVNode.key;\r\n    var nextKey = nextVNode.key;\r\n    if (lastType !== nextType || lastKey !== nextKey) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n        return false;\r\n    }\r\n    else {\r\n        var nextProps = nextVNode.props || EMPTY_OBJ;\r\n        if (isClass) {\r\n            var instance = lastVNode.children;\r\n            instance._updating = true;\r\n            if (instance._unmounted) {\r\n                if (isNull(parentDom)) {\r\n                    return true;\r\n                }\r\n                replaceChild(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, (nextVNode.flags & 4 /* ComponentClass */) > 0), lastVNode.dom);\r\n            }\r\n            else {\r\n                var hasComponentDidUpdate = !isUndefined(instance.componentDidUpdate);\r\n                var nextState = instance.state;\r\n                // When component has componentDidUpdate hook, we need to clone lastState or will be modified by reference during update\r\n                var lastState = hasComponentDidUpdate\r\n                    ? combineFrom(nextState, null)\r\n                    : nextState;\r\n                var lastProps = instance.props;\r\n                var childContext;\r\n                if (!isNullOrUndef(instance.getChildContext)) {\r\n                    childContext = instance.getChildContext();\r\n                }\r\n                nextVNode.children = instance;\r\n                instance._isSVG = isSVG;\r\n                if (isNullOrUndef(childContext)) {\r\n                    childContext = context;\r\n                }\r\n                else {\r\n                    childContext = combineFrom(context, childContext);\r\n                }\r\n                var lastInput = instance._lastInput;\r\n                var nextInput = instance._updateComponent(lastState, nextState, lastProps, nextProps, context, false, false);\r\n                var didUpdate = true;\r\n                instance._childContext = childContext;\r\n                if (isInvalid(nextInput)) {\r\n                    nextInput = createVoidVNode();\r\n                }\r\n                else if (nextInput === NO_OP) {\r\n                    nextInput = lastInput;\r\n                    didUpdate = false;\r\n                }\r\n                else if (isStringOrNumber(nextInput)) {\r\n                    nextInput = createTextVNode(nextInput, null);\r\n                }\r\n                else if (isArray(nextInput)) {\r\n                    if (process.env.NODE_ENV !== \"production\") {\r\n                        throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n                    }\r\n                    throwError();\r\n                }\r\n                else if (isObject(nextInput)) {\r\n                    if (!isNull(nextInput.dom)) {\r\n                        nextInput = directClone(nextInput);\r\n                    }\r\n                }\r\n                if (nextInput.flags & 28 /* Component */) {\r\n                    nextInput.parentVNode = nextVNode;\r\n                }\r\n                else if (lastInput.flags & 28 /* Component */) {\r\n                    lastInput.parentVNode = nextVNode;\r\n                }\r\n                instance._lastInput = nextInput;\r\n                instance._vNode = nextVNode;\r\n                if (didUpdate) {\r\n                    patch(lastInput, nextInput, parentDom, lifecycle, childContext, isSVG, isRecycling);\r\n                    if (hasComponentDidUpdate && instance.componentDidUpdate) {\r\n                        instance.componentDidUpdate(lastProps, lastState);\r\n                    }\r\n                    if (!isNull(options.afterUpdate)) {\r\n                        options.afterUpdate(nextVNode);\r\n                    }\r\n                    if (options.findDOMNodeEnabled) {\r\n                        componentToDOMNodeMap.set(instance, nextInput.dom);\r\n                    }\r\n                }\r\n                nextVNode.dom = nextInput.dom;\r\n            }\r\n            instance._updating = false;\r\n        }\r\n        else {\r\n            var shouldUpdate = true;\r\n            var lastProps$1 = lastVNode.props;\r\n            var nextHooks = nextVNode.ref;\r\n            var nextHooksDefined = !isNullOrUndef(nextHooks);\r\n            var lastInput$1 = lastVNode.children;\r\n            var nextInput$1 = lastInput$1;\r\n            nextVNode.dom = lastVNode.dom;\r\n            nextVNode.children = lastInput$1;\r\n            if (lastKey !== nextKey) {\r\n                shouldUpdate = true;\r\n            }\r\n            else {\r\n                if (nextHooksDefined &&\r\n                    !isNullOrUndef(nextHooks.onComponentShouldUpdate)) {\r\n                    shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps$1, nextProps);\r\n                }\r\n            }\r\n            if (shouldUpdate !== false) {\r\n                if (nextHooksDefined &&\r\n                    !isNullOrUndef(nextHooks.onComponentWillUpdate)) {\r\n                    nextHooks.onComponentWillUpdate(lastProps$1, nextProps);\r\n                }\r\n                nextInput$1 = nextType(nextProps, context);\r\n                if (isInvalid(nextInput$1)) {\r\n                    nextInput$1 = createVoidVNode();\r\n                }\r\n                else if (isStringOrNumber(nextInput$1) && nextInput$1 !== NO_OP) {\r\n                    nextInput$1 = createTextVNode(nextInput$1, null);\r\n                }\r\n                else if (isArray(nextInput$1)) {\r\n                    if (process.env.NODE_ENV !== \"production\") {\r\n                        throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n                    }\r\n                    throwError();\r\n                }\r\n                else if (isObject(nextInput$1)) {\r\n                    if (!isNull(nextInput$1.dom)) {\r\n                        nextInput$1 = directClone(nextInput$1);\r\n                    }\r\n                }\r\n                if (nextInput$1 !== NO_OP) {\r\n                    patch(lastInput$1, nextInput$1, parentDom, lifecycle, context, isSVG, isRecycling);\r\n                    nextVNode.children = nextInput$1;\r\n                    if (nextHooksDefined &&\r\n                        !isNullOrUndef(nextHooks.onComponentDidUpdate)) {\r\n                        nextHooks.onComponentDidUpdate(lastProps$1, nextProps);\r\n                    }\r\n                    nextVNode.dom = nextInput$1.dom;\r\n                }\r\n            }\r\n            if (nextInput$1.flags & 28 /* Component */) {\r\n                nextInput$1.parentVNode = nextVNode;\r\n            }\r\n            else if (lastInput$1.flags & 28 /* Component */) {\r\n                lastInput$1.parentVNode = nextVNode;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction patchText(lastVNode, nextVNode) {\r\n    var nextText = nextVNode.children;\r\n    var dom = lastVNode.dom;\r\n    nextVNode.dom = dom;\r\n    if (lastVNode.children !== nextText) {\r\n        dom.nodeValue = nextText;\r\n    }\r\n}\r\nfunction patchVoid(lastVNode, nextVNode) {\r\n    nextVNode.dom = lastVNode.dom;\r\n}\r\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var lastChildrenLength = lastChildren.length;\r\n    var nextChildrenLength = nextChildren.length;\r\n    var commonLength = lastChildrenLength > nextChildrenLength\r\n        ? nextChildrenLength\r\n        : lastChildrenLength;\r\n    var i = 0;\r\n    for (; i < commonLength; i++) {\r\n        var nextChild = nextChildren[i];\r\n        if (nextChild.dom) {\r\n            nextChild = nextChildren[i] = directClone(nextChild);\r\n        }\r\n        patch(lastChildren[i], nextChild, dom, lifecycle, context, isSVG, isRecycling);\r\n    }\r\n    if (lastChildrenLength < nextChildrenLength) {\r\n        for (i = commonLength; i < nextChildrenLength; i++) {\r\n            var nextChild$1 = nextChildren[i];\r\n            if (nextChild$1.dom) {\r\n                nextChild$1 = nextChildren[i] = directClone(nextChild$1);\r\n            }\r\n            appendChild(dom, mount(nextChild$1, null, lifecycle, context, isSVG));\r\n        }\r\n    }\r\n    else if (nextChildrenLength === 0) {\r\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\r\n    }\r\n    else if (lastChildrenLength > nextChildrenLength) {\r\n        for (i = commonLength; i < lastChildrenLength; i++) {\r\n            unmount(lastChildren[i], dom, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction patchKeyedChildren(a, b, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var aLength = a.length;\r\n    var bLength = b.length;\r\n    var aEnd = aLength - 1;\r\n    var bEnd = bLength - 1;\r\n    var aStart = 0;\r\n    var bStart = 0;\r\n    var i;\r\n    var j;\r\n    var aNode;\r\n    var bNode;\r\n    var nextNode;\r\n    var nextPos;\r\n    var node;\r\n    if (aLength === 0) {\r\n        if (bLength > 0) {\r\n            mountArrayChildren(b, dom, lifecycle, context, isSVG);\r\n        }\r\n        return;\r\n    }\r\n    else if (bLength === 0) {\r\n        removeAllChildren(dom, a, lifecycle, isRecycling);\r\n        return;\r\n    }\r\n    var aStartNode = a[aStart];\r\n    var bStartNode = b[bStart];\r\n    var aEndNode = a[aEnd];\r\n    var bEndNode = b[bEnd];\r\n    if (bStartNode.dom) {\r\n        b[bStart] = bStartNode = directClone(bStartNode);\r\n    }\r\n    if (bEndNode.dom) {\r\n        b[bEnd] = bEndNode = directClone(bEndNode);\r\n    }\r\n    // Step 1\r\n    /* eslint no-constant-condition: 0 */\r\n    outer: while (true) {\r\n        // Sync nodes with the same key at the beginning.\r\n        while (aStartNode.key === bStartNode.key) {\r\n            patch(aStartNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            aStart++;\r\n            bStart++;\r\n            if (aStart > aEnd || bStart > bEnd) {\r\n                break outer;\r\n            }\r\n            aStartNode = a[aStart];\r\n            bStartNode = b[bStart];\r\n            if (bStartNode.dom) {\r\n                b[bStart] = bStartNode = directClone(bStartNode);\r\n            }\r\n        }\r\n        // Sync nodes with the same key at the end.\r\n        while (aEndNode.key === bEndNode.key) {\r\n            patch(aEndNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            aEnd--;\r\n            bEnd--;\r\n            if (aStart > aEnd || bStart > bEnd) {\r\n                break outer;\r\n            }\r\n            aEndNode = a[aEnd];\r\n            bEndNode = b[bEnd];\r\n            if (bEndNode.dom) {\r\n                b[bEnd] = bEndNode = directClone(bEndNode);\r\n            }\r\n        }\r\n        // Move and sync nodes from right to left.\r\n        if (aEndNode.key === bStartNode.key) {\r\n            patch(aEndNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            insertOrAppend(dom, bStartNode.dom, aStartNode.dom);\r\n            aEnd--;\r\n            bStart++;\r\n            aEndNode = a[aEnd];\r\n            bStartNode = b[bStart];\r\n            if (bStartNode.dom) {\r\n                b[bStart] = bStartNode = directClone(bStartNode);\r\n            }\r\n            continue;\r\n        }\r\n        // Move and sync nodes from left to right.\r\n        if (aStartNode.key === bEndNode.key) {\r\n            patch(aStartNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            nextPos = bEnd + 1;\r\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n            insertOrAppend(dom, bEndNode.dom, nextNode);\r\n            aStart++;\r\n            bEnd--;\r\n            aStartNode = a[aStart];\r\n            bEndNode = b[bEnd];\r\n            if (bEndNode.dom) {\r\n                b[bEnd] = bEndNode = directClone(bEndNode);\r\n            }\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    if (aStart > aEnd) {\r\n        if (bStart <= bEnd) {\r\n            nextPos = bEnd + 1;\r\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n            while (bStart <= bEnd) {\r\n                node = b[bStart];\r\n                if (node.dom) {\r\n                    b[bStart] = node = directClone(node);\r\n                }\r\n                bStart++;\r\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n            }\r\n        }\r\n    }\r\n    else if (bStart > bEnd) {\r\n        while (aStart <= aEnd) {\r\n            unmount(a[aStart++], dom, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n    else {\r\n        aLength = aEnd - aStart + 1;\r\n        bLength = bEnd - bStart + 1;\r\n        var sources = new Array(bLength);\r\n        // Mark all nodes as inserted.\r\n        for (i = 0; i < bLength; i++) {\r\n            sources[i] = -1;\r\n        }\r\n        var moved = false;\r\n        var pos = 0;\r\n        var patched = 0;\r\n        // When sizes are small, just loop them through\r\n        if (bLength <= 4 || aLength * bLength <= 16) {\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLength) {\r\n                    for (j = bStart; j <= bEnd; j++) {\r\n                        bNode = b[j];\r\n                        if (aNode.key === bNode.key) {\r\n                            sources[j - bStart] = i;\r\n                            if (pos > j) {\r\n                                moved = true;\r\n                            }\r\n                            else {\r\n                                pos = j;\r\n                            }\r\n                            if (bNode.dom) {\r\n                                b[j] = bNode = directClone(bNode);\r\n                            }\r\n                            patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\r\n                            patched++;\r\n                            a[i] = null;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var keyIndex = new Map();\r\n            // Map keys by their index in array\r\n            for (i = bStart; i <= bEnd; i++) {\r\n                keyIndex.set(b[i].key, i);\r\n            }\r\n            // Try to patch same keys\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLength) {\r\n                    j = keyIndex.get(aNode.key);\r\n                    if (!isUndefined(j)) {\r\n                        bNode = b[j];\r\n                        sources[j - bStart] = i;\r\n                        if (pos > j) {\r\n                            moved = true;\r\n                        }\r\n                        else {\r\n                            pos = j;\r\n                        }\r\n                        if (bNode.dom) {\r\n                            b[j] = bNode = directClone(bNode);\r\n                        }\r\n                        patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\r\n                        patched++;\r\n                        a[i] = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // fast-path: if nothing patched remove all old and add all new\r\n        if (aLength === a.length && patched === 0) {\r\n            removeAllChildren(dom, a, lifecycle, isRecycling);\r\n            while (bStart < bLength) {\r\n                node = b[bStart];\r\n                if (node.dom) {\r\n                    b[bStart] = node = directClone(node);\r\n                }\r\n                bStart++;\r\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), null);\r\n            }\r\n        }\r\n        else {\r\n            i = aLength - patched;\r\n            while (i > 0) {\r\n                aNode = a[aStart++];\r\n                if (!isNull(aNode)) {\r\n                    unmount(aNode, dom, lifecycle, true, isRecycling);\r\n                    i--;\r\n                }\r\n            }\r\n            if (moved) {\r\n                var seq = lis_algorithm(sources);\r\n                j = seq.length - 1;\r\n                for (i = bLength - 1; i >= 0; i--) {\r\n                    if (sources[i] === -1) {\r\n                        pos = i + bStart;\r\n                        node = b[pos];\r\n                        if (node.dom) {\r\n                            b[pos] = node = directClone(node);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                        insertOrAppend(dom, mount(node, dom, lifecycle, context, isSVG), nextNode);\r\n                    }\r\n                    else {\r\n                        if (j < 0 || i !== seq[j]) {\r\n                            pos = i + bStart;\r\n                            node = b[pos];\r\n                            nextPos = pos + 1;\r\n                            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                            insertOrAppend(dom, node.dom, nextNode);\r\n                        }\r\n                        else {\r\n                            j--;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (patched !== bLength) {\r\n                // when patched count doesn't match b length we need to insert those new ones\r\n                // loop backwards so we can use insertBefore\r\n                for (i = bLength - 1; i >= 0; i--) {\r\n                    if (sources[i] === -1) {\r\n                        pos = i + bStart;\r\n                        node = b[pos];\r\n                        if (node.dom) {\r\n                            b[pos] = node = directClone(node);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n// // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction lis_algorithm(arr) {\r\n    var p = arr.slice(0);\r\n    var result = [0];\r\n    var i;\r\n    var j;\r\n    var u;\r\n    var v;\r\n    var c;\r\n    var len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var arrI = arr[i];\r\n        if (arrI === -1) {\r\n            continue;\r\n        }\r\n        j = result[result.length - 1];\r\n        if (arr[j] < arrI) {\r\n            p[i] = j;\r\n            result.push(i);\r\n            continue;\r\n        }\r\n        u = 0;\r\n        v = result.length - 1;\r\n        while (u < v) {\r\n            c = ((u + v) / 2) | 0;\r\n            if (arr[result[c]] < arrI) {\r\n                u = c + 1;\r\n            }\r\n            else {\r\n                v = c;\r\n            }\r\n        }\r\n        if (arrI < arr[result[u]]) {\r\n            if (u > 0) {\r\n                p[i] = result[u - 1];\r\n            }\r\n            result[u] = i;\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\r\nfunction isAttrAnEvent(attr) {\r\n    return attr[0] === \"o\" && attr[1] === \"n\";\r\n}\r\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue) {\r\n    if (lastValue !== nextValue) {\r\n        if (skipProps.has(prop) || (hasControlledValue && prop === \"value\")) {\r\n            return;\r\n        }\r\n        else if (booleanProps.has(prop)) {\r\n            prop = prop === \"autoFocus\" ? prop.toLowerCase() : prop;\r\n            dom[prop] = !!nextValue;\r\n        }\r\n        else if (strictProps.has(prop)) {\r\n            var value = isNullOrUndef(nextValue) ? \"\" : nextValue;\r\n            if (dom[prop] !== value) {\r\n                dom[prop] = value;\r\n            }\r\n        }\r\n        else if (isAttrAnEvent(prop)) {\r\n            patchEvent(prop, lastValue, nextValue, dom);\r\n        }\r\n        else if (isNullOrUndef(nextValue)) {\r\n            dom.removeAttribute(prop);\r\n        }\r\n        else if (prop === \"style\") {\r\n            patchStyle(lastValue, nextValue, dom);\r\n        }\r\n        else if (prop === \"dangerouslySetInnerHTML\") {\r\n            var lastHtml = lastValue && lastValue.__html;\r\n            var nextHtml = nextValue && nextValue.__html;\r\n            if (lastHtml !== nextHtml) {\r\n                if (!isNullOrUndef(nextHtml)) {\r\n                    dom.innerHTML = nextHtml;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // We optimize for NS being boolean. Its 99.9% time false\r\n            if (isSVG && namespaces.has(prop)) {\r\n                // If we end up in this path we can read property again\r\n                dom.setAttributeNS(namespaces.get(prop), prop, nextValue);\r\n            }\r\n            else {\r\n                dom.setAttribute(prop, nextValue);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction patchEvent(name, lastValue, nextValue, dom) {\r\n    if (lastValue !== nextValue) {\r\n        if (delegatedEvents.has(name)) {\r\n            handleEvent(name, lastValue, nextValue, dom);\r\n        }\r\n        else {\r\n            var nameLowerCase = name.toLowerCase();\r\n            var domEvent = dom[nameLowerCase];\r\n            // if the function is wrapped, that means it's been controlled by a wrapper\r\n            if (domEvent && domEvent.wrapped) {\r\n                return;\r\n            }\r\n            if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {\r\n                var linkEvent = nextValue.event;\r\n                if (linkEvent && isFunction(linkEvent)) {\r\n                    dom[nameLowerCase] = function (e) {\r\n                        linkEvent(nextValue.data, e);\r\n                    };\r\n                }\r\n                else {\r\n                    if (process.env.NODE_ENV !== \"production\") {\r\n                        throwError((\"an event on a VNode \\\"\" + name + \"\\\". was not a function or a valid linkEvent.\"));\r\n                    }\r\n                    throwError();\r\n                }\r\n            }\r\n            else {\r\n                dom[nameLowerCase] = nextValue;\r\n            }\r\n        }\r\n    }\r\n}\r\n// We are assuming here that we come from patchProp routine\r\n// -nextAttrValue cannot be null or undefined\r\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\r\n    var domStyle = dom.style;\r\n    var style;\r\n    var value;\r\n    if (isString(nextAttrValue)) {\r\n        domStyle.cssText = nextAttrValue;\r\n        return;\r\n    }\r\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\r\n        for (style in nextAttrValue) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            value = nextAttrValue[style];\r\n            if (value !== lastAttrValue[style]) {\r\n                domStyle[style] = !isNumber(value) || isUnitlessNumber.has(style)\r\n                    ? value\r\n                    : value + \"px\";\r\n            }\r\n        }\r\n        for (style in lastAttrValue) {\r\n            if (isNullOrUndef(nextAttrValue[style])) {\r\n                domStyle[style] = \"\";\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (style in nextAttrValue) {\r\n            value = nextAttrValue[style];\r\n            domStyle[style] = !isNumber(value) || isUnitlessNumber.has(style)\r\n                ? value\r\n                : value + \"px\";\r\n        }\r\n    }\r\n}\r\nfunction removeProp(prop, lastValue, dom, nextFlags) {\r\n    if (prop === \"value\") {\r\n        // When removing value of select element, it needs to be set to null instead empty string, because empty string is valid value for option which makes that option selected\r\n        // MS IE/Edge don't follow html spec for textArea and input elements and we need to set empty string to value in those cases to avoid \"null\" and \"undefined\" texts\r\n        dom.value = nextFlags & 2048 /* SelectElement */ ? null : \"\";\r\n    }\r\n    else if (prop === \"style\") {\r\n        dom.removeAttribute(\"style\");\r\n    }\r\n    else if (isAttrAnEvent(prop)) {\r\n        handleEvent(prop, lastValue, null, dom);\r\n    }\r\n    else {\r\n        dom.removeAttribute(prop);\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction mount(vNode, parentDom, lifecycle, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 3970 /* Element */) {\r\n        return mountElement(vNode, parentDom, lifecycle, context, isSVG);\r\n    }\r\n    else if (flags & 28 /* Component */) {\r\n        return mountComponent(vNode, parentDom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    else if (flags & 4096 /* Void */) {\r\n        return mountVoid(vNode, parentDom);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        return mountText(vNode, parentDom);\r\n    }\r\n    else {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            if (typeof vNode === \"object\") {\r\n                throwError((\"mount() received an object that's not a valid VNode, you should stringify it first. Object: \\\"\" + (JSON.stringify(vNode)) + \"\\\".\"));\r\n            }\r\n            else {\r\n                throwError((\"mount() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\r\n            }\r\n        }\r\n        throwError();\r\n    }\r\n}\r\nfunction mountText(vNode, parentDom) {\r\n    var dom = document.createTextNode(vNode.children);\r\n    vNode.dom = dom;\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountVoid(vNode, parentDom) {\r\n    var dom = document.createTextNode(\"\");\r\n    vNode.dom = dom;\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountElement(vNode, parentDom, lifecycle, context, isSVG) {\r\n    if (options.recyclingEnabled) {\r\n        var dom$1 = recycleElement(vNode, lifecycle, context, isSVG);\r\n        if (!isNull(dom$1)) {\r\n            if (!isNull(parentDom)) {\r\n                appendChild(parentDom, dom$1);\r\n            }\r\n            return dom$1;\r\n        }\r\n    }\r\n    var flags = vNode.flags;\r\n    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;\r\n    var dom = documentCreateElement(vNode.type, isSVG);\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var ref = vNode.ref;\r\n    vNode.dom = dom;\r\n    if (!isInvalid(children)) {\r\n        if (isStringOrNumber(children)) {\r\n            setTextContent(dom, children);\r\n        }\r\n        else {\r\n            var childrenIsSVG = isSVG === true && vNode.type !== \"foreignObject\";\r\n            if (isArray(children)) {\r\n                mountArrayChildren(children, dom, lifecycle, context, childrenIsSVG);\r\n            }\r\n            else if (isVNode(children)) {\r\n                mount(children, dom, lifecycle, context, childrenIsSVG);\r\n            }\r\n        }\r\n    }\r\n    if (!isNull(props)) {\r\n        var hasControlledValue = false;\r\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\r\n        if (isFormElement) {\r\n            hasControlledValue = isControlledFormElement(props);\r\n        }\r\n        for (var prop in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\r\n        }\r\n        if (isFormElement) {\r\n            processElement(flags, vNode, dom, props, true, hasControlledValue);\r\n        }\r\n    }\r\n    if (className !== null) {\r\n        if (isSVG) {\r\n            dom.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n    }\r\n    if (!isNull(ref)) {\r\n        mountRef(dom, ref, lifecycle);\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountArrayChildren(children, dom, lifecycle, context, isSVG) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        var child = children[i];\r\n        // Verify can string/number be here. might cause de-opt. - Normalization takes care of it.\r\n        if (!isInvalid(child)) {\r\n            if (child.dom) {\r\n                children[i] = child = directClone(child);\r\n            }\r\n            mount(children[i], dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n}\r\nfunction mountComponent(vNode, parentDom, lifecycle, context, isSVG, isClass) {\r\n    if (options.recyclingEnabled) {\r\n        var dom$1 = recycleComponent(vNode, lifecycle, context, isSVG);\r\n        if (!isNull(dom$1)) {\r\n            if (!isNull(parentDom)) {\r\n                appendChild(parentDom, dom$1);\r\n            }\r\n            return dom$1;\r\n        }\r\n    }\r\n    var type = vNode.type;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var ref = vNode.ref;\r\n    var dom;\r\n    if (isClass) {\r\n        var instance = createClassComponentInstance(vNode, type, props, context, isSVG, lifecycle);\r\n        var input = instance._lastInput;\r\n        instance._vNode = vNode;\r\n        vNode.dom = dom = mount(input, null, lifecycle, instance._childContext, isSVG);\r\n        if (!isNull(parentDom)) {\r\n            appendChild(parentDom, dom);\r\n        }\r\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\r\n        instance._updating = false;\r\n        if (options.findDOMNodeEnabled) {\r\n            componentToDOMNodeMap.set(instance, dom);\r\n        }\r\n    }\r\n    else {\r\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\r\n        vNode.dom = dom = mount(input$1, null, lifecycle, context, isSVG);\r\n        vNode.children = input$1;\r\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\r\n        if (!isNull(parentDom)) {\r\n            appendChild(parentDom, dom);\r\n        }\r\n    }\r\n    return dom;\r\n}\r\nfunction mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {\r\n    if (ref) {\r\n        if (isFunction(ref)) {\r\n            ref(instance);\r\n        }\r\n        else {\r\n            if (process.env.NODE_ENV !== \"production\") {\r\n                if (isStringOrNumber(ref)) {\r\n                    throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n                }\r\n                else if (isObject(ref) && vNode.flags & 4 /* ComponentClass */) {\r\n                    throwError(\"functional component lifecycle events are not supported on ES2015 class components.\");\r\n                }\r\n                else {\r\n                    throwError((\"a bad value for \\\"ref\\\" was used on component: \\\"\" + (JSON.stringify(ref)) + \"\\\"\"));\r\n                }\r\n            }\r\n            throwError();\r\n        }\r\n    }\r\n    var hasDidMount = !isUndefined(instance.componentDidMount);\r\n    var afterMount = options.afterMount;\r\n    if (hasDidMount || !isNull(afterMount)) {\r\n        lifecycle.addListener((function () {\r\n            instance._updating = true;\r\n            if (afterMount) {\r\n                afterMount(vNode);\r\n            }\r\n            if (hasDidMount) {\r\n                instance.componentDidMount();\r\n            }\r\n            instance._updating = false;\r\n        }));\r\n    }\r\n}\r\nfunction mountFunctionalComponentCallbacks(ref, dom, lifecycle) {\r\n    if (ref) {\r\n        if (!isNullOrUndef(ref.onComponentWillMount)) {\r\n            ref.onComponentWillMount();\r\n        }\r\n        if (!isNullOrUndef(ref.onComponentDidMount)) {\r\n            lifecycle.addListener((function () { return ref.onComponentDidMount(dom); }));\r\n        }\r\n    }\r\n}\r\nfunction mountRef(dom, value, lifecycle) {\r\n    if (isFunction(value)) {\r\n        lifecycle.addListener((function () { return value(dom); }));\r\n    }\r\n    else {\r\n        if (isInvalid(value)) {\r\n            return;\r\n        }\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n        }\r\n        throwError();\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n// We need EMPTY_OBJ defined in one place.\r\n// Its used for comparison so we cant inline it into shared\r\nvar EMPTY_OBJ = {};\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    Object.freeze(EMPTY_OBJ);\r\n}\r\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\r\n    if (isUndefined(context)) {\r\n        context = EMPTY_OBJ; // Context should not be mutable\r\n    }\r\n    var instance = new Component(props, context);\r\n    vNode.children = instance;\r\n    instance._blockSetState = false;\r\n    instance.context = context;\r\n    if (instance.props === EMPTY_OBJ) {\r\n        instance.props = props;\r\n    }\r\n    // setState callbacks must fire after render is done when called from componentWillReceiveProps or componentWillMount\r\n    instance._lifecycle = lifecycle;\r\n    instance._unmounted = false;\r\n    instance._pendingSetState = true;\r\n    instance._isSVG = isSVG;\r\n    if (!isNullOrUndef(instance.componentWillMount)) {\r\n        instance._blockRender = true;\r\n        instance.componentWillMount();\r\n        instance._blockRender = false;\r\n    }\r\n    var childContext;\r\n    if (!isNullOrUndef(instance.getChildContext)) {\r\n        childContext = instance.getChildContext();\r\n    }\r\n    if (isNullOrUndef(childContext)) {\r\n        instance._childContext = context;\r\n    }\r\n    else {\r\n        instance._childContext = combineFrom(context, childContext);\r\n    }\r\n    if (!isNull(options.beforeRender)) {\r\n        options.beforeRender(instance);\r\n    }\r\n    var input = instance.render(props, instance.state, context);\r\n    if (!isNull(options.afterRender)) {\r\n        options.afterRender(instance);\r\n    }\r\n    if (isArray(input)) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n        }\r\n        throwError();\r\n    }\r\n    else if (isInvalid(input)) {\r\n        input = createVoidVNode();\r\n    }\r\n    else if (isStringOrNumber(input)) {\r\n        input = createTextVNode(input, null);\r\n    }\r\n    else {\r\n        if (input.dom) {\r\n            input = directClone(input);\r\n        }\r\n        if (input.flags & 28 /* Component */) {\r\n            // if we have an input that is also a component, we run into a tricky situation\r\n            // where the root vNode needs to always have the correct DOM entry\r\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\r\n            // we can optimise this in the future, but this gets us out of a lot of issues\r\n            input.parentVNode = vNode;\r\n        }\r\n    }\r\n    instance._pendingSetState = false;\r\n    instance._lastInput = input;\r\n    return instance;\r\n}\r\nfunction replaceLastChildAndUnmount(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    replaceVNode(parentDom, mount(nextInput, null, lifecycle, context, isSVG), lastInput, lifecycle, isRecycling);\r\n}\r\nfunction replaceVNode(parentDom, dom, vNode, lifecycle, isRecycling) {\r\n    unmount(vNode, null, lifecycle, false, isRecycling);\r\n    replaceChild(parentDom, dom, vNode.dom);\r\n}\r\nfunction createFunctionalComponentInput(vNode, component, props, context) {\r\n    var input = component(props, context);\r\n    if (isArray(input)) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n        }\r\n        throwError();\r\n    }\r\n    else if (isInvalid(input)) {\r\n        input = createVoidVNode();\r\n    }\r\n    else if (isStringOrNumber(input)) {\r\n        input = createTextVNode(input, null);\r\n    }\r\n    else {\r\n        if (input.dom) {\r\n            input = directClone(input);\r\n        }\r\n        if (input.flags & 28 /* Component */) {\r\n            // if we have an input that is also a component, we run into a tricky situation\r\n            // where the root vNode needs to always have the correct DOM entry\r\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\r\n            // we can optimise this in the future, but this gets us out of a lot of issues\r\n            input.parentVNode = vNode;\r\n        }\r\n    }\r\n    return input;\r\n}\r\nfunction setTextContent(dom, text) {\r\n    if (text !== \"\") {\r\n        dom.textContent = text;\r\n    }\r\n    else {\r\n        dom.appendChild(document.createTextNode(\"\"));\r\n    }\r\n}\r\nfunction updateTextContent(dom, text) {\r\n    dom.firstChild.nodeValue = text;\r\n}\r\nfunction appendChild(parentDom, dom) {\r\n    parentDom.appendChild(dom);\r\n}\r\nfunction insertOrAppend(parentDom, newNode, nextNode) {\r\n    if (isNullOrUndef(nextNode)) {\r\n        appendChild(parentDom, newNode);\r\n    }\r\n    else {\r\n        parentDom.insertBefore(newNode, nextNode);\r\n    }\r\n}\r\nfunction documentCreateElement(tag, isSVG) {\r\n    if (isSVG === true) {\r\n        return document.createElementNS(svgNS, tag);\r\n    }\r\n    else {\r\n        return document.createElement(tag);\r\n    }\r\n}\r\nfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    unmount(lastNode, null, lifecycle, false, isRecycling);\r\n    var dom = mount(nextNode, null, lifecycle, context, isSVG);\r\n    nextNode.dom = dom;\r\n    replaceChild(parentDom, dom, lastNode.dom);\r\n}\r\nfunction replaceChild(parentDom, nextDom, lastDom) {\r\n    if (!parentDom) {\r\n        parentDom = lastDom.parentNode;\r\n    }\r\n    parentDom.replaceChild(nextDom, lastDom);\r\n}\r\nfunction removeChild(parentDom, dom) {\r\n    parentDom.removeChild(dom);\r\n}\r\nfunction removeAllChildren(dom, children, lifecycle, isRecycling) {\r\n    if (!options.recyclingEnabled || (options.recyclingEnabled && !isRecycling)) {\r\n        removeChildren(null, children, lifecycle, isRecycling);\r\n    }\r\n    dom.textContent = \"\";\r\n}\r\nfunction removeChildren(dom, children, lifecycle, isRecycling) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        var child = children[i];\r\n        if (!isInvalid(child)) {\r\n            unmount(child, dom, lifecycle, true, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction isKeyed(lastChildren, nextChildren) {\r\n    return (nextChildren.length > 0 &&\r\n        !isNullOrUndef(nextChildren[0]) &&\r\n        !isNullOrUndef(nextChildren[0].key) &&\r\n        lastChildren.length > 0 &&\r\n        !isNullOrUndef(lastChildren[0]) &&\r\n        !isNullOrUndef(lastChildren[0].key));\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction VNode(children, className, flags, key, props, ref, type) {\r\n    this.children = children;\r\n    this.className = className;\r\n    this.dom = null;\r\n    this.flags = flags;\r\n    this.key = key;\r\n    this.props = props;\r\n    this.ref = ref;\r\n    this.type = type;\r\n}\r\n/**\r\n * Creates virtual node\r\n * @param {number} flags\r\n * @param {string|Function|null} type\r\n * @param {string|null=} className\r\n * @param {object=} children\r\n * @param {object=} props\r\n * @param {*=} key\r\n * @param {object|Function=} ref\r\n * @param {boolean=} noNormalise\r\n * @returns {VNode} returns new virtual node\r\n */\r\nfunction createVNode(flags, type, className, children, props, key, ref, noNormalise) {\r\n    if (flags & 16 /* ComponentUnknown */) {\r\n        flags = isStatefulComponent(type)\r\n            ? 4 /* ComponentClass */\r\n            : 8 /* ComponentFunction */;\r\n    }\r\n    var vNode = new VNode(children === void 0 ? null : children, className === void 0 ? null : className, flags, key === void 0 ? null : key, props === void 0 ? null : props, ref === void 0 ? null : ref, type);\r\n    if (noNormalise !== true) {\r\n        normalize(vNode);\r\n    }\r\n    if (options.createVNode !== null) {\r\n        options.createVNode(vNode);\r\n    }\r\n    return vNode;\r\n}\r\nfunction directClone(vNodeToClone) {\r\n    var newVNode;\r\n    var flags = vNodeToClone.flags;\r\n    if (flags & 28 /* Component */) {\r\n        var props;\r\n        var propsToClone = vNodeToClone.props;\r\n        if (isNull(propsToClone)) {\r\n            props = EMPTY_OBJ;\r\n        }\r\n        else {\r\n            props = {};\r\n            for (var key in propsToClone) {\r\n                props[key] = propsToClone[key];\r\n            }\r\n        }\r\n        newVNode = createVNode(flags, vNodeToClone.type, null, null, props, vNodeToClone.key, vNodeToClone.ref, true);\r\n        var newProps = newVNode.props;\r\n        var newChildren = newProps.children;\r\n        // we need to also clone component children that are in props\r\n        // as the children may also have been hoisted\r\n        if (newChildren) {\r\n            if (isArray(newChildren)) {\r\n                var len = newChildren.length;\r\n                if (len > 0) {\r\n                    var tmpArray = [];\r\n                    for (var i = 0; i < len; i++) {\r\n                        var child = newChildren[i];\r\n                        if (isStringOrNumber(child)) {\r\n                            tmpArray.push(child);\r\n                        }\r\n                        else if (!isInvalid(child) && isVNode(child)) {\r\n                            tmpArray.push(directClone(child));\r\n                        }\r\n                    }\r\n                    newProps.children = tmpArray;\r\n                }\r\n            }\r\n            else if (isVNode(newChildren)) {\r\n                newProps.children = directClone(newChildren);\r\n            }\r\n        }\r\n        newVNode.children = null;\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        var children = vNodeToClone.children;\r\n        var props$1;\r\n        var propsToClone$1 = vNodeToClone.props;\r\n        if (propsToClone$1 === null) {\r\n            props$1 = EMPTY_OBJ;\r\n        }\r\n        else {\r\n            props$1 = {};\r\n            for (var key$1 in propsToClone$1) {\r\n                props$1[key$1] = propsToClone$1[key$1];\r\n            }\r\n        }\r\n        newVNode = createVNode(flags, vNodeToClone.type, vNodeToClone.className, children, props$1, vNodeToClone.key, vNodeToClone.ref, !children);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        newVNode = createTextVNode(vNodeToClone.children, vNodeToClone.key);\r\n    }\r\n    return newVNode;\r\n}\r\n/*\r\n directClone is preferred over cloneVNode and used internally also.\r\n This function makes Inferno backwards compatible.\r\n And can be tree-shaked by modern bundlers\r\n\n Would be nice to combine this with directClone but could not do it without breaking change\r\n */\r\n/**\r\n * Clones given virtual node by creating new instance of it\r\n * @param {VNode} vNodeToClone virtual node to be cloned\r\n * @param {Props=} props additional props for new virtual node\r\n * @param {...*} _children new children for new virtual node\r\n * @returns {VNode} new virtual node\r\n */\r\nfunction cloneVNode(vNodeToClone, props) {\n    var _children = [], len$2 = arguments.length - 2;\n    while ( len$2-- > 0 ) _children[ len$2 ] = arguments[ len$2 + 2 ];\n\r\n    var children = _children;\r\n    var childrenLen = _children.length;\r\n    if (childrenLen > 0 && !isUndefined(_children[0])) {\r\n        if (!props) {\r\n            props = {};\r\n        }\r\n        if (childrenLen === 1) {\r\n            children = _children[0];\r\n        }\r\n        if (!isUndefined(children)) {\r\n            props.children = children;\r\n        }\r\n    }\r\n    var newVNode;\r\n    if (isArray(vNodeToClone)) {\r\n        var tmpArray = [];\r\n        for (var i = 0, len = vNodeToClone.length; i < len; i++) {\r\n            tmpArray.push(directClone(vNodeToClone[i]));\r\n        }\r\n        newVNode = tmpArray;\r\n    }\r\n    else {\r\n        var flags = vNodeToClone.flags;\r\n        var className = vNodeToClone.className;\r\n        var key = vNodeToClone.key;\r\n        var ref = vNodeToClone.ref;\r\n        if (props) {\r\n            if (props.hasOwnProperty(\"className\")) {\r\n                className = props.className;\r\n            }\r\n            if (props.hasOwnProperty(\"ref\")) {\r\n                ref = props.ref;\r\n            }\r\n            if (props.hasOwnProperty(\"key\")) {\r\n                key = props.key;\r\n            }\r\n        }\r\n        if (flags & 28 /* Component */) {\r\n            newVNode = createVNode(flags, vNodeToClone.type, className, null, !vNodeToClone.props && !props\r\n                ? EMPTY_OBJ\r\n                : combineFrom(vNodeToClone.props, props), key, ref, true);\r\n            var newProps = newVNode.props;\r\n            if (newProps) {\r\n                var newChildren = newProps.children;\r\n                // we need to also clone component children that are in props\r\n                // as the children may also have been hoisted\r\n                if (newChildren) {\r\n                    if (isArray(newChildren)) {\r\n                        var len$1 = newChildren.length;\r\n                        if (len$1 > 0) {\r\n                            var tmpArray$1 = [];\r\n                            for (var i$1 = 0; i$1 < len$1; i$1++) {\r\n                                var child = newChildren[i$1];\r\n                                if (isStringOrNumber(child)) {\r\n                                    tmpArray$1.push(child);\r\n                                }\r\n                                else if (!isInvalid(child) && isVNode(child)) {\r\n                                    tmpArray$1.push(directClone(child));\r\n                                }\r\n                            }\r\n                            newProps.children = tmpArray$1;\r\n                        }\r\n                    }\r\n                    else if (isVNode(newChildren)) {\r\n                        newProps.children = directClone(newChildren);\r\n                    }\r\n                }\r\n            }\r\n            newVNode.children = null;\r\n        }\r\n        else if (flags & 3970 /* Element */) {\r\n            children = props && !isUndefined(props.children)\r\n                ? props.children\r\n                : vNodeToClone.children;\r\n            newVNode = createVNode(flags, vNodeToClone.type, className, children, !vNodeToClone.props && !props\r\n                ? EMPTY_OBJ\r\n                : combineFrom(vNodeToClone.props, props), key, ref, false);\r\n        }\r\n        else if (flags & 1 /* Text */) {\r\n            newVNode = createTextVNode(vNodeToClone.children, key);\r\n        }\r\n    }\r\n    return newVNode;\r\n}\r\nfunction createVoidVNode() {\r\n    return createVNode(4096 /* Void */, null);\r\n}\r\nfunction createTextVNode(text, key) {\r\n    return createVNode(1 /* Text */, null, null, text, null, key);\r\n}\r\nfunction isVNode(o) {\r\n    return !!o.flags;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction applyKey(key, vNode) {\r\n    vNode.key = key;\r\n    return vNode;\r\n}\r\nfunction applyKeyIfMissing(key, vNode) {\r\n    if (isNumber(key)) {\r\n        key = \".\" + key;\r\n    }\r\n    if (isNull(vNode.key) || vNode.key[0] === \".\") {\r\n        return applyKey(key, vNode);\r\n    }\r\n    return vNode;\r\n}\r\nfunction applyKeyPrefix(key, vNode) {\r\n    vNode.key = key + vNode.key;\r\n    return vNode;\r\n}\r\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\r\n    for (var len = nodes.length; index < len; index++) {\r\n        var n = nodes[index];\r\n        var key = currentKey + \".\" + index;\r\n        if (!isInvalid(n)) {\r\n            if (isArray(n)) {\r\n                _normalizeVNodes(n, result, 0, key);\r\n            }\r\n            else {\r\n                if (isStringOrNumber(n)) {\r\n                    n = createTextVNode(n, null);\r\n                }\r\n                else if ((isVNode(n) && n.dom) || (n.key && n.key[0] === \".\")) {\r\n                    n = directClone(n);\r\n                }\r\n                if (isNull(n.key) || n.key[0] === \".\") {\r\n                    n = applyKey(key, n);\r\n                }\r\n                else {\r\n                    n = applyKeyPrefix(currentKey, n);\r\n                }\r\n                result.push(n);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction normalizeVNodes(nodes) {\r\n    var newNodes;\r\n    // we assign $ which basically means we've flagged this array for future note\r\n    // if it comes back again, we need to clone it, as people are using it\r\n    // in an immutable way\r\n    // tslint:disable\r\n    if (nodes[\"$\"] === true) {\r\n        nodes = nodes.slice();\r\n    }\r\n    else {\r\n        nodes[\"$\"] = true;\r\n    }\r\n    // tslint:enable\r\n    for (var i = 0, len = nodes.length; i < len; i++) {\r\n        var n = nodes[i];\r\n        if (isInvalid(n) || isArray(n)) {\r\n            var result = (newNodes || nodes).slice(0, i);\r\n            _normalizeVNodes(nodes, result, i, \"\");\r\n            return result;\r\n        }\r\n        else if (isStringOrNumber(n)) {\r\n            if (!newNodes) {\r\n                newNodes = nodes.slice(0, i);\r\n            }\r\n            newNodes.push(applyKeyIfMissing(i, createTextVNode(n, null)));\r\n        }\r\n        else if ((isVNode(n) && n.dom !== null) ||\r\n            (isNull(n.key) && (n.flags & 64 /* HasNonKeyedChildren */) === 0)) {\r\n            if (!newNodes) {\r\n                newNodes = nodes.slice(0, i);\r\n            }\r\n            newNodes.push(applyKeyIfMissing(i, directClone(n)));\r\n        }\r\n        else if (newNodes) {\r\n            newNodes.push(applyKeyIfMissing(i, directClone(n)));\r\n        }\r\n    }\r\n    return newNodes || nodes;\r\n}\r\nfunction normalizeChildren(children) {\r\n    if (isArray(children)) {\r\n        return normalizeVNodes(children);\r\n    }\r\n    else if (isVNode(children) && children.dom !== null) {\r\n        return directClone(children);\r\n    }\r\n    return children;\r\n}\r\nfunction normalizeProps(vNode, props, children) {\r\n    if (vNode.flags & 3970 /* Element */) {\r\n        if (isNullOrUndef(children) && props.hasOwnProperty(\"children\")) {\r\n            vNode.children = props.children;\r\n        }\r\n        if (props.hasOwnProperty(\"className\")) {\r\n            vNode.className = props.className || null;\r\n            delete props.className;\r\n        }\r\n    }\r\n    if (props.hasOwnProperty(\"ref\")) {\r\n        vNode.ref = props.ref;\r\n        delete props.ref;\r\n    }\r\n    if (props.hasOwnProperty(\"key\")) {\r\n        vNode.key = props.key;\r\n        delete props.key;\r\n    }\r\n}\r\nfunction getFlagsForElementVnode(type) {\r\n    if (type === \"svg\") {\r\n        return 128 /* SvgElement */;\r\n    }\r\n    else if (type === \"input\") {\r\n        return 512 /* InputElement */;\r\n    }\r\n    else if (type === \"select\") {\r\n        return 2048 /* SelectElement */;\r\n    }\r\n    else if (type === \"textarea\") {\r\n        return 1024 /* TextareaElement */;\r\n    }\r\n    else if (type === \"media\") {\r\n        return 256 /* MediaElement */;\r\n    }\r\n    return 2 /* HtmlElement */;\r\n}\r\nfunction normalize(vNode) {\r\n    var props = vNode.props;\r\n    var children = vNode.children;\r\n    // convert a wrongly created type back to element\r\n    // Primitive node doesn't have defaultProps, only Component\r\n    if (vNode.flags & 28 /* Component */) {\r\n        // set default props\r\n        var type = vNode.type;\r\n        var defaultProps = type.defaultProps;\r\n        if (!isNullOrUndef(defaultProps)) {\r\n            if (!props) {\r\n                props = vNode.props = defaultProps; // Create new object if only defaultProps given\r\n            }\r\n            else {\r\n                for (var prop in defaultProps) {\r\n                    if (isUndefined(props[prop])) {\r\n                        props[prop] = defaultProps[prop];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (isString(type)) {\r\n            vNode.flags = getFlagsForElementVnode(type);\r\n            if (props && props.children) {\r\n                vNode.children = props.children;\r\n                children = props.children;\r\n            }\r\n        }\r\n    }\r\n    if (props) {\r\n        normalizeProps(vNode, props, children);\r\n        if (!isInvalid(props.children)) {\r\n            props.children = normalizeChildren(props.children);\r\n        }\r\n    }\r\n    if (!isInvalid(children)) {\r\n        vNode.children = normalizeChildren(children);\r\n    }\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n        // This code will be stripped out from production CODE\r\n        // It helps users to track errors in their applications.\r\n        var verifyKeys = function (vNodes) {\r\n            var keyValues = vNodes.map((function (vnode) {\r\n                return vnode.key;\r\n            }));\r\n            keyValues.some((function (item, idx) {\r\n                var hasDuplicate = keyValues.indexOf(item) !== idx;\r\n                if (hasDuplicate) {\r\n                    warning(\"Inferno normalisation(...): Encountered two children with same key, all keys must be unique within its siblings. Duplicated key is:\" +\r\n                        item);\r\n                }\r\n                return hasDuplicate;\r\n            }));\r\n        };\r\n        if (vNode.children && Array.isArray(vNode.children)) {\r\n            verifyKeys(vNode.children);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * Links given data to event as first parameter\r\n * @param {*} data data to be linked, it will be available in function as first parameter\r\n * @param {Function} event Function to be called when event occurs\r\n * @returns {{data: *, event: Function}}\r\n */\r\nfunction linkEvent(data, event) {\r\n    if (isFunction(event)) {\r\n        return { data: data, event: event };\r\n    }\r\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/* tslint:disable:object-literal-sort-keys */\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    /* tslint:disable-next-line:no-empty */\r\n    var testFunc = function testFn() { };\r\n    if ((testFunc.name || testFunc.toString()).indexOf(\"testFn\") ===\r\n        -1) {\r\n        warning(\"It looks like you're using a minified copy of the development build \" +\r\n            \"of Inferno. When deploying Inferno apps to production, make sure to use \" +\r\n            \"the production build which skips development warnings and is faster. \" +\r\n            \"See http://infernojs.org for more details.\");\r\n    }\r\n}\r\nvar version = \"3.6.1\";\r\n// we duplicate it so it plays nicely with different module loading systems\r\nvar index = {\r\n    EMPTY_OBJ: EMPTY_OBJ,\r\n    NO_OP: NO_OP,\r\n    cloneVNode: cloneVNode,\r\n    createRenderer: createRenderer,\r\n    createVNode: createVNode,\r\n    findDOMNode: findDOMNode,\r\n    getFlagsForElementVnode: getFlagsForElementVnode,\r\n    internal_DOMNodeMap: componentToDOMNodeMap,\r\n    internal_isUnitlessNumber: isUnitlessNumber,\r\n    internal_normalize: normalize,\r\n    internal_patch: patch,\r\n    linkEvent: linkEvent,\r\n    options: options,\r\n    render: render,\r\n    version: version\r\n};\n\nexports['default'] = index;\nexports.EMPTY_OBJ = EMPTY_OBJ;\nexports.NO_OP = NO_OP;\nexports.cloneVNode = cloneVNode;\nexports.createRenderer = createRenderer;\nexports.createVNode = createVNode;\nexports.findDOMNode = findDOMNode;\nexports.getFlagsForElementVnode = getFlagsForElementVnode;\nexports.internal_DOMNodeMap = componentToDOMNodeMap;\nexports.internal_isUnitlessNumber = isUnitlessNumber;\nexports.internal_normalize = normalize;\nexports.internal_patch = patch;\nexports.linkEvent = linkEvent;\nexports.options = options;\nexports.render = render;\nexports.version = version;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/inferno/dist/index.js\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}